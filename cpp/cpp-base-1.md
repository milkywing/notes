## 变量和类型

### 基本类型

基本类型包括**算术类型（整型、浮点）**和**空类型（void）**

| 整型类型                  | 含义         | 大小                              |
| ------------------------- | ------------ | --------------------------------- |
| short                     | 短整型       | 典型大小 2                        |
| int（整型字面值默认类型） | 整型         | `>=sizeof(short)`，典型大小 4     |
| long                      | 长整型       | `>=sizeof(int)`，典型大小 8       |
| long long                 | 长整型       | `>=sizeof(long long)`，典型大小 8 |
| char                      | 字符         | 1                                 |
| wchar_t                   | 宽字符       | 典型大小 4                        |
| char16_t                  | Unicode 字符 | 2                                 |
| char32_t                  | Unicode 字符 | 4                                 |
| bool                      | 布尔         | 典型大小 1                        |

> 整型/字符可以通过在类型名前添加 `unsigned` 转换为无符号整型/字符
>
> 字面值可以添加 `U` 后缀来标识无符号，类似的后缀还有 `LL/F` 分别对应长整型和单精度浮点

| 浮点类型                     | 含义         | 典型大小     |
| ---------------------------- | ------------ | ------------ |
| float                        | 单精度浮点   | 4，有效位 7  |
| double（浮点字面值默认类型） | 双精度浮点   | 8，有效位 15 |
| long double                  | 扩展进度浮点 | --           |

> C++ 并未规定整型的精确大小，只要求了整型的大小不能小于低一级的整型，因此如果需要存储大值建议一步到位使用 `long long`（这一点同样适用于浮点）
>
> 类型大小和类型转换的存在，会带来潜在的溢出的可能。建议开发者合理选择类型，切勿混用无符号整型和有符号整型

### 变量

在类型说明符后面接若干个变量名（逗号分隔）来定义变量；定义变量的时候可同时赋予初始值，没有赋初值的变量将执行默认初始化（具体取决于类型本身）

```c++
int num, *pnum; // 定义整型变量 num 和整型指针变量 pnum
int v1, v2 = 2; // 定义整型变量 v1、v2，其中 v2 初始化为 2，v1 默认初始化为 0
```

一下几种方式都能在定义变量的时候同时执行初始化

```c++
int v1 = 1
int v2 = {2}
int v3{3} // 对于内置类型的变量，大括号初始化的方式会检查类型转换时的信息丢失并报错
int v4(4)
```

> 变量的初始化和赋值是两个不同的操作，要注意区分
>
> - 初始化指创建变量的时候赋予一个初始值
> - 赋值指的是擦除当前值并用新值替代

定义在文件顶层的变量将在全局作用域生效，在分离式编译中若其他文件想要共享这个变量，需要对该变量作出 `extern` 声明，表示该变量在其他地方被定义了

```c++
// file1.cc
int share = 1;
// file2.cc
extern int share;
std::out << share; // 1
```

变量的作用域遵循静态的词法作用域（以大括号为边界），内层作用域同名变量覆盖外层，变量查找从当前作用域向外层查找

### 复合类型（左值引用、指针）

复合类型包括引用和指针，由声明符 `&/*` 指示

- 在变量名前加 `&` 声明符来定义引用（左值），引用定义时必须绑定到已有的对象上（初始化）；引用相当于对象的别名，操作引用其实就是操作引用绑定的值
- 在变量名前加 `*` 声明符来定义指针，指针是一种存储对象地址的对象，指向地址对应的对象；通过 `*` 操作符号来解引用指针访问对象；通过 `&` 操作符来取得对象的地址

```c++
int num = 1;
int &rnum = num; // 为引用绑定对象
int *pnum = &num; // 让指针指向对象
std::out << *pnum; // 1，解引用指针来访问指针指向的对象
rnum = 2;
std::out << num; // 2
```

> 引用并不是对象，因此不能让指针指向引用；指针是对象，因此引用可以绑到指针上
>
> ```c++
> // pref 是一个引用，绑定到了一个整型指针上
> int *&pref = &num
> ```
>
> 如何辨别声明语句的类型？谨记**「从括号内到括号外，从右到左，离变量名最近的声明符有最直接影响」**
>
> 使用/解引用指针时需确保指针确实指向某个存在的对象，建议定义指针时初始化指针

### const/constexpr 限定符

`const` 限定符号用于指示常量，放置于类型前或声明符 `*` 后，常量必须初始化

```c++
// num0 是一个常量，无法改变
const int num0 = 1；

// pnum1 是一个指向常量的指针，不能改变指针指向的值（指针本身不是常量）
const int *pnum1;
// pnum2 是一个常量指针，之后不能改变指针的指向（指针本身是常量，必须初始化）
int *const pnum2 = &num0;
// pnum3 是一个常量指针，并且指向常量，不能改变指针的指向也不能改变指针指向的值
const int *const pnum3 = &num0;
```

> 再次强调，**「从括号内到括号外，从右到左，离变量名最近的声明符有最直接影响」**

`const` 有顶层和底层之分

- 顶层 `const` 指的是变量本身是常量，值无法改变
- 底层 `const` 只存在于指针/引用中，指向常量的指针和绑定常量的引用属于底层 `const`，无法改变其指向/绑定的值

> 底层 `const` 中。常量引用仅限制了引用的操作（只读），对绑定的对象本身是否是常量并无限制，绑定的对象可以是常量的，也可以是非常量的（在这种情况下绑定的对象可能通过其他途径改变）；指向常量的指针同理，对指向的对象是否是常量并无限制
>
> 因为底层 `const` 的限制，底层 `const` 的标识会像类型的一样左右着拷贝控制和函数参数的匹配（非常量可以赋值给底层 `const`，但底层 `const` 只能赋值给底层 `const` ）

`const` 常量默认只会在本文件可见，如果其他文件需要共享该常量，需要在定义时加上 `extern` 关键字，在其他文件使用时对该变量作出 `extern` 声明

```c++
// file1.cc
const int share = 1;
// file2.cc
extern const int share;
std::out << share; // 1
```

`constexpr` 限定符用于指示常量表达式（编译时常量），其值必须在编译阶段计算出来（通常来自其他常 `constexpr` 变量/函数），否则编译器会报错

> `constexpr` 指针只能指向固定地址的对象，比如全局/静态变量；`constexpr` 引用同理

使用 `typedef/using` 关键字来定义类型别名

```c++
// 在单一声明语句前加上 typedef，变量名就会变成类型的别名
typedef int *pnum;
// p1 是整型指针
pnum p1;
// 类型别名的另一种定义方式
using pnum = int*;
```

### 类型推断

可以使用 `auto` 类型说明符来声明并初始化变量来让编译器自己根据值推断变量的类型，`auto` 声明会忽略掉顶层 `const`，如果需要声明常量需要在声明时重新加上 `const` 限定符

如果只需要推断的类型而不想初始化，也可以使用 `decltype(exp)/decltype((exp))` 类型说明符从某个表达式中获取其类型。双括号的版本会推断出引用类型；而单括号版本只会在表达式是引用时才会推断出引用

```c++
int num = 0, &rnum = num;
// v1 推断为 int
auto v1 = rnum;
// v2 推断为 int&
decltype(rnum) v2 = num;
// v3 推断为 int&
decltype((num)) v3 = num;
```

> 对于引用类型，`auto` 推断的类型不是引用，但 `decltype()` 推断出来的是引用

## 基础使用

### 字符串、向量和数组

C++ 的内置函数库大多在 `std` 命名空间下，使用相关函数库时需要引入相关头文件并在指定名字在命名空间中的位置

可以使用 `using` 声明来引入某个名字或使用 `using` 指示来引入命名空间中的所有名字，之后在使用名字的时候就无需指定完整的路径

```c++
#include <iostream> // 输入输出所需头文件
#include <string> // string 所需头文件

// 使用 std 命名空间下的 string
std::string str = "string";
// 1. using 声明 std::out，之后可以直接使用 out
using std::cout;
cout << str;
// 2. using 指示 std，之后可以直接使用当前头文件下所有 std 下名字
using namespace std;
cin << cout;

```

标准库类型 `string` 表示可变长字符串，默认初始化为空字符串，其构造函数有两种形式：

- `string(strLike s)`，其中 `strLike` 可以是 `string/char[]`，以指定字符串为原本构造副本字符串
- `string(int repeat, char c)`，用指定字符重复指定次数构造字符串

> 字符串字面值其实是 `char[]`

基于以上两种形式的构造函数，有如下初始化方式

```c++
// 拷贝初始化，以等号右边的值为原本构造对象（适用单参数非 explicit 构造函数）
string s1 = "s1";
// 直接/构造初始化，直接调用构造函数
string s2(s1);
string s3(3, 'c');
```

> 类的拷贝初始化和直接初始化是两种不同的初始化方式，前者使用等号拷贝，后者直接调用构造函数

如需 IO 读写 `string`，可以使用如下方式

```c++
string str;
// 从输入流中读取字符串写入 str，遇到空字符停止
cin >> str;
// 读取字符串写入 str，遇到换行符才会停止，并且丢弃该换行符号
getline(cin, str);
```

另外和其他语言中的字符串用法类似，`s.size()` 获取大小、`s.empty()` 判断是否为空；`string` 之间可以使用 `+` 进行拼接，使用比较运算符以字典序进行比较

> `s.size()` 返回一个 `string::size_type` 类型，这是一个无符号类型，注意不要和有符号数在表达式中混用
>
> `string` 可以和字符串字面值相加，此时字符串字面值被包装转换为一个 `string` 再执行相加操作（因为 `string` 的构造函数是非 explicit 的 ）

可以通过循环/随机的方式访问 `string` 中的字符，`string` 可以下标索引的形式随机访问字符（需确保索引的位置在长度范围之内）

```c++
string str("1234");
cout << str[1]; // 2
for (char c : str) cout << c; // 1234
// 这里的 c 是引用，可以通过 c 修改
for (char &c : str) c++; // str = 2345
```

对于字符的处理，`cctype` 头文件提供了许多便捷函数，如判断是否为字母 `isalpha(c)`、大小写转换`tolower/toupper(c)`等

------

标准库类型 `vector` 表示向量（可变长数组），默认初始化为空向量，其构造函数有三种形式：

- `vector<T>(v)`，其中 `v` 是另外一个 `vector`，以指定向量为原本构造向量
- `vector<T>(int count, [T val])`，构造一个有 `count` 个元素，且每个元素都是 `val` 的向量（如果不提供 `cout`，则元素根据其类型进行默认初始化）

> `vector` 是一个模板（其用法和其他语言的泛型有点类似），`<T>` 说明了向量中元素的类型

## 表达式

字符串的另一种形式字符数组比较特别，字符数组的长度总是会比字符串的长度多 1，用于专门存储尾部的空字符。要处理字符数组，需要用到 C 中的函数（`cstring` 头文件），比如 `strlen()` 获取字符串长度、`strcmp()` 比较字符串、`strcat()` 拼接字符串、`strcpy()` 拷贝字符串

> 数组不允许拷贝和赋值，但数组是对象允许被引用
>
> 再三强调，**「从括号内到括号外，从右到左，离变量名最近的声明符有最直接影响」**
>
> ```c++
> // 优先和中括号绑定，所以首先是一个长度为 10 的数组，元素类型为整型指针
> int *ptrs[3];
> // 优先和 & 绑定，所以首先是一个引用，绑定到数组 nums 上
> int (&numsRef)[3] = nums; 
> ```
