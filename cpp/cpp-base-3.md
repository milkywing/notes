## IO

### 基础流（`iostream` 头文件）

标准库提供了三种流基类，分别为==输入流 istream==、==输出流 ostream==和==读写流 iostream==，并在此基础上派生出==文件流==用于读写文件、==字符串流==用于读写字符串，像最常使用的 `cin` 和 `cout` 就分别属于基础输入流和基础输出流。标准库所有流都继承自基础流，这意味着对 `cin` 和 `cout` 对象的所有操作同样适用其他派生流对象，比如使用移位运算符进行读写、 `getline()` 读取一行等。所有流都可以使用如下成员

| 成员 | 描述 |
| ------------- | ---- |
| stream::badbit, bool stream::bad() | 崩溃标记（系统级别，不可恢复）及崩溃判断 |
| stream::failbit, bool stream::fail() | 失效标记（操作失败导致）及失效判断 |
| stream::eofbit, bool stream::eof() | 尾部标记及尾部判断 |
| stream::goodbit, bool stream::good() | 生效标记及生效判断 |
| void stream::clear() | 重置所有标记位 |
| isolate stream::rdstate() | 返回流的状态（标记快照） |
| void stream::setstate(isolate flags) | 将流设置为指定状态 |

流一旦发生错误（比如执行了一个不支持的操作）或者到达尾部，流的 `failbit` 就会被置位并且进入失效状态，后续对流的操作都将失效。**失效状态的流在条件表达式中会隐式的转换为 `false`，因此可以将流本身或者值为流的表达式作为判断条件**

输出流维护着一个缓冲区用于暂存写入的数据，并且在缓冲刷新时执行真正的输出操作。程序正常结束以及缓冲区满时会自动刷新缓冲区，开发者也可以使用操纵符 `flush`（只刷新）、`endl`（输出换行并刷新）或 `ends`（输出空字符并刷新）来显式的刷新缓冲区；若想在每次写操作后自动刷新，也可以使用操纵符 `unitbuf`

> 和数组、函数类似，**流对象无法被拷贝**

### 文件流（`fstream` 头文件）

文件流允许开发者流式的读写文件，包括==ifstream（读）==、==ofstream（写）==和==fstream（读写）==三种类型，其特有的成员如下

| 成员                                     | 描述                                          |
| ---------------------------------------- | --------------------------------------------- |
| fstream::fstream()                       | 默认构造函数，构造一未绑定文件的流            |
| fstream::fstream(string path)            | `explicit` 构造函数，构造一个绑定指定文件的流 |
| fstream::fstream(string path, mode mode) | 以指定模式构造一个绑定指定文件的流            |
| void fstream::open(string path)          | 将流绑定到指定文件                            |
| void fstream::close()                    | 取消流绑定的文件                              |
| bool fstream::is_open()                  | 判断流是否成功绑定到文件                      |

文件流在读写之前必须绑定文件，流和文件是一对一的绑定关系，在绑定其他文件之前必须确保流是未绑定状态，**重复绑定或绑定失败会导致文件流 `failbit` 置位并进入失效状态**。文件流对象被销毁时会自动调用 `close()` 完成解绑，如果没有重复绑定的需要 `close()` 通常是不需要的手动调用的

文件流绑定文件时可以指定==文件模式==，对应参数中的 `mode`

- `in`-以读方式打开
- `out`-以写方式打开（隐含 `trunc`）
- `app`-尾部追加写（隐含 `out`，但是排除 `trunc`）
- `trunc`-截断模式（覆盖原文件内容）
- `ate`-读写前定位到文件末尾
- `binary`-以二进制方式读写

每种文件模式都是以二进制的形式表示占位，使用多个模式需使用逻辑或运算符 `|` 拼接。未指定模式的的流会采用流的默认模式，`ifstream` 的默认模式是 `in`；`ofstream` 的默认模式是 `out`；`fstream` 的默认模式是 `in | out`

### 字符串流（`sstream` 头文件）

字符串流允许开发者流式的读写字符串数据，包括==istringstream（读）==、==ostringstream（写）==和==stringstream（读写）==三种类型，其特有的成员如下

| 成员                        | 描述                                            |
| --------------------------- | ----------------------------------------------- |
| sstream::sstream()          | 默认构造函数，构造一个空的流                    |
| sstream::sstream(string s)  | `explicit` 构造函数，以指定字符串初始化流的内容 |
| string sstream::str()       | 以字符串的形式返回流的内容                      |
| void sstream::str(string s) | 使用指定字符串填充流                            |

## 顺序容器

容器指的是特定类型对象的集合，包括==顺序容器==和==关联容器==两类，容器都是模板类（泛型），定义在对应的同名头文件中。碍于篇幅限制，这里先介绍顺序容器

顺序容器提供了控制元素存储和访问顺序的能力，主要分成四大类，可根据实际场景选用

- 数组：包括==不定长数组 vector==、==定长数组 array==，可随机访问
- 队列：只有==双端队列 deque==，可随机访问，在两端插入/删除性能高
- 链表：包括==双向链表 list==、==单向链表 forward_list==，不支持随机访问，任意位置插入/删除性能高
- 字符串：只有==不定长字符串 string==，可随机访问

> 和数组一样，**`array` 的大小是类型的一部分**，由第二个泛型参数指明，如 `array<int, 10> a;`

### 容器共有操作

下面介绍顺序容器和关联容器的共有操作，非共有操作会特别提示

#### 共有类型成员

- `C::iterator/const_iterator`，容器的正向迭代器类型
- `C::reverse_iterator/const_reverse_iterator`，容器的反向迭代器类型
- `C::difference_type`，有符号整型，用于表示两个迭代器之间的距离
- `C::size_type`，无符号整型，用于表示容器大小
- `C::value_type`，元素类型
- `C::reference/const_reference`，元素左值引用类型

#### 共有构造函数

- `C()`，默认构造函数
  - 对于 `array`，构造对应大小，元素默认初始化的容器
  - 对于非 `array`，构造空容器

- `C(c)`，以指定容器为原本构造副本容器，容器类型必须严格相等
- `C(ib, ie)`，以迭代器范围 `[ib, ie)` 中的值为初始元素构造容器**（`array` 不适用）**
- `C(il)`，以初始化列表中的值为初始元素构造容器

容器进行赋值拷贝时（对应构造函数 `C(c)`），两者容器类型必须严格相等；但如果是通过迭代器范围或初始化列表的形式拷贝（对应构造函数 `C(ib, ie)` 和 `C(il)`），只要元素类型能转换，不强求容器类型相等

```c++
vector<double> vd = {1, 2, 3};
vector<int> vi1(v2.begin(), v2.end()); // 正确，浮点类型可转换为整型
vector<int> vi2 = vd; // 错误，拷贝赋值时，容器类型必须严格相等（包括元素类型）
```

另外还有两个构造函数为顺序容器共有（除去 `array`），用于在构造时指定容器大小

- `C(n)`，构造大小为 `n`，元素默认初始化的容器**（`string` 不适用）**
- `C(n, v)`，构造大小为 `n`，元素都为 `v` 副本的容器

#### 共有赋值操作

- `swap(c1, c2)/c1.swap(c2)`，交换两个容器的元素，通常会比赋值拷贝快
- `c.assign(ib, ie)`，将容器中的元素替换为迭代器范围 `[ib, ie)` 中的元素
- `c.assign(il)`，将容器中的元素替换为初始化列表 `il` 中的元素
- `c.assign(n, v)`，将容器中的元素替换为 `n` 个指定元素 `v`

> `assign` 操作会使容器内的迭代器、引用和指针失效，但是 `swap` 操作不会（因为 `swap` 只交换的两个元素的数据结构，元素本身并没有移动，`string` 除外）
>
> `assign` 操作不适用于定长 `array` 和关联容器

#### 共有大小操作

- `c.size()`，获取容器元素数量**（`forward_list` 不适用）**
- `c.max_size()`，获取容器能承载的元素数量上限
- `c.empty()`，判断是否为空容器

#### 共有比较操作

所有容器都支持相等运算符（`== / !=`），除了无序关联容器的容器都支持关系运算符（`> / >= / < / <=`）

容器比较操作的实质是对元素进行逐个比较，**因此容器能比较的前提是元素支持对应的比较操作**（容器的相等性比较需要元素实现 `==`，容器的大小性比较需要元素实现 `<`）

> 容器比较要求两个容器类型严格相等

#### 共有元素操作

- `c.insert(args)`系列函数，将指定的若干个元素副本插入到容器的指定位置
- `c.emplace(inits)`系列函数，构造一个元素插入到容器的指定位置
- `c.erase(args)`，删除指定元素
- `c.clear()`，清空容器

> 部分容器会因为自身特性导致无法支持部分操作，或者入参定义不一样

### 顺序容器操作

#### 插入元素

插入元素操作可以分成三类

- 头部插入（仅链表和双端队列适用），`c.push_front(v)/c.emplace_front(inits)`，在头部插入指定元素 `v` 或者以 `inits` 构造元素插入到头部
- 尾部插入，`c.push_back(v)/c.emplace_back(inits)`，在尾部插入指定元素 `v` 或者以 `inits` 构造元素插入到尾部
- 指定位置插入（返回指向第一个插入元素的迭代器）
  - `c.insert(ip, v)`，在指定位置 `ip`（迭代器，下同）之前插入指定元素 `v`
  - `c.insert(ip, n, v)`，在指定位置之前插入 `n` 个指定元素 `v`
  - `c.insert(ip, ib, ie)`，在指定位置之前插入迭代器范围 `[ib, ie)` 中的元素
  - `c.insert(ip, il)`，在指定位置之前插入初始化列表 `il` 中的元素
  - `c.emplace(ip, inits)`，以 `inits` 构造元素插入到指定位置之前

> 对于 `vector`、`string` 和 `deque`（空间是连续的容器）来说，执行插入操作会导致容器内的迭代器、引用和指针失效
>
> 容器插入操作实际上插入的是目标元素的副本（`assign` 操作同理）

#### 删除元素

- 头部删除（仅链表和双端队列适用），`c.pop_front()`，无返回值
- 尾部删除**（`forward_list` 不适用）**，`c.pop_back()`，无返回值
- 指定位置删除（返回指向最后一个被删元素之后元素的迭代器）
  - `c.erase(ip)`，删除指定位置 `ip` 的元素
  - `c.erase(ib, ie)`，删除指定范围 `[ib, ie)` 范围中的元素
  - `c.clear()`，删除所有元素

> 对于空间是连续的容器来说，执行删除操作会导致容器内的迭代器、引用和指针失效（`deque` 的头尾删除不受影响）
>
> 删除元素前需确保删除的位置未越界

#### 访问元素

- `c.front()`，获取首元素引用
- `c.back()`，获取尾元素引用**（`forward_list` 不适用）**
- `c[n]/c.at(n)`，获取下标为 `n` 的元素引用**（仅随机访问容器支持）**，其中 `c.at(n)` 是安全的随机访问，会在越界访问时抛异常

> 访问元素前需确保访问的位置未越界

#### 改变容器大小

`c.resize(n, [v])` 可以改变容器的大小，若 `n` 大于当前大小则截断容器；若 `n` 小于当前大小则使用指定值 `v` 填充剩余位置（未指定则默认初始化）

#### 单向链表特有操作

单向链表不支持普通的 `insert/erase()`，他有自己的一套插入/删除元素的操作。要在单向链表的某个位置上进行操作，必须已知这个位置的前驱

- `lst.before_begin/cbefore_begin()`，获取指向==首前元素==（第一个元素的前一个位置，仅为标记，实际上不存在元素）的迭代器
- `lst.insert_after(args)`，其中 `args` 同 `c.insert(args)`，在指定前驱后插入指定元素，返回指向最后一个插入元素的迭代器
- `lst.emplace_after(ip, inits)`，以 `inits` 构造元素插入到指定前驱 `ip` 后，返回指向，返回指向插入元素的迭代器
- `lst.erase_after(args)`，其中 `args` 同 `c.erase(args)`，删除指定前驱后的指定元素，返回指向被删元素之后元素的迭代器

#### 字符串特有操作

插入操作的描述由两部分组成，分别是目标位置和插入内容。所有容器都支持使用迭代器参数 `ip` 指示目标位置，并且通过参数组合 `(n, v)/(ib, ie)/(il)` 中的一种指示插入内容。

字符串额外重载了 `insert`，可以使用下标 `p` 来指示目标位置，并且通过参数组合 `strRange` 指示其他字符串中的一段作为插入内容，`strRange` 可以是如下参数组合中的一种

- `str`，插入内容是完整字符串 `str`
- `str, p, [n]`，插入内容是字符串 `str` 从下标 `p` 开始长度为 `n` 的部分（未指定长度则默认取到尾部）
- `cp, [n]`，插入内容是字符数组 `cp` 的前 `n` 个字符

> 对于插入操作，如果使用下标 `p` 来指示目标位置，那只能使用以上提到的 `strRange` 参数组合来指示插入内容，两者是绑定的

基于下标的重载函数还有删除、赋值操作

- `s.erase(p, [n])`，从下标 `p` 开始删除长度 `n` 个字符（未指定则删除至尾部）
- `s.assign(strRange)`，将字符串替换为指定内容 `strRange`

修改字符串的其他操作

- `s.append(strRange)`，将指定内容 `strRange` 串追加到字符串尾部
- `s.replace(p, n, strRange)`，下标版本目标位置替换，从下标 `p` 开始长度为 `n` 范围，替换为指定内容 `strRange`
- `s.replace(ib, ie, strRange)`，迭代器版本目标位置替换，将指定范围 `[ib, ie)` 替换为指定内容 `strRange`

字符串的搜索操作，返回第一个匹配的下标，若未找到则返回静态 `string::npos`

- `s.find/rfind(args)`，正向/反向查找目标字符串出现的位置
- `s.find_first_of/find_last_of(args)`，正向/反向查找目标字符集中任一字符出现的位置
- `s.find_first_not_of/find_last_not_of(args)`，正向/反向查找非目标字符集中任一字符出现的位置

> `args` 参数格式为 `s/c/cp, p`，从源字符串的下标 `p` 开始搜索的目标字符串/字符 `s/c/cp`
>
> 字符串搜索返回的位置为无符号整数，不应该和有符号整数混用

字符串的其他操作

- `s.substr(p, [n])`，从下标 `p` 开始截取长度为 `n` 的子串并返回（未指定则截取至尾部）
- `to_string(v)`，将其他算术类型值 `v` 转换为字符串
- `stoXXX(s)`，一系列函数，将字符串 `s` 转换为对应的算术类型，若无法转换/转换值无法承载将的抛异常

#### 顺序容器操作注意事项

对内存空间上连续的顺序容器（`vector` 和 `string`）

- 元素插入有可能导致空间重新分配，导致容器内所有迭代器（包括元素的指针和引用，下同）失效
- 无论是插入/删除元素都会重排目标位置之后的元素，因此目标位置之后的迭代器都会失效

对于双向队列 `deque`，头尾的操作不会影响现有迭代器的可用性；但中间的操作会触发重排导致容器内所有迭代器失效

对于链表（`list` 和 `forward_list`），新增和删除元素都不会影响现有迭代器的可用性

> 容器操作对迭代器、指针和引用的影响，取决于容器操作是如何对待内存空间
>
> 因为容器操作可能会导致迭代器失效，引出了如下两条建议
>
> - 不要存储尾后迭代器，而是在需要的地方每次调用 `c.end()` 获取
> - 在 `insert/erase` 后利用其返回值及时更新迭代器

### 容器适配器

容器适配器包括==栈 stack==、==队列 queue==和==优先队列 priority==，他们提供了对应数据结构的相关操作。容器适配器可以默认初始化，也可以初始化时从指定的顺序容器中继承初始元素

```c++
deque<int> d({1, 2, 3});
// queue 可以从 list/deque 容器中继承初始之
queue<int> q(d); // 1-2-3
q.push(4); // 1-2-3-4
q.pop(); // 2-3-4
```

> 容器适配器在初始化时对继承容器类型的要求，依赖于数据结构的特性。比如队列要求头尾插入/访问/删除，只能继承双向链表或双向队列

## 泛型算法

==泛型算法==（下称算法）是一组基于迭代器的算法，这些算法通过遍历元素并执行元素类型上的相关操作实现相关功能。所有顺序容器都提供了迭代器，因此只要元素支持相关操作，这些算法适用于所有顺序容器

> 算法通常定义在头文件 `algoritm` 中，部分数值相关的泛型算法则定义在 `numeric` 中
>
> 算法不依赖容器，因此算法永远不会改变容器的大小，只能基于迭代器修改或移动内部的元素

标准库中的算法数量多达百余种，但入参结构类似，因此下面只介绍常用算法的使用，其他算法的使用可以查阅[相关文档](https://www.apiref.com/cpp-zh/cpp/algorithm.html)

一些算法接受一个迭代器范围 `[ib, ie)`（下称 `range`），并对范围内的执行指定操作

- `find(range, v)`，在指定范围 `range` 中寻找目标值 `v` 并返回起目标迭代器，若未找到则返回 `ie`

- `accumulate(range, initv)`，对指定范围中的值求和，`initv` 是初始值
- `count(range, v)`，在指定范围中统计值为 `v` 的元素个数
- `fill(range, v)`，将指定范围中的元素全写为指定值 `v`
- `replace(range, v, r)`，将指定范围中值为 `v` 的元素全替换为 `r`

一些算法接受起始迭代器和一个长度 `(ip, n)` 来表示范围，比如 `fill_n(ip, n, v)`，从位置 `ip` 开始的 `n` 个元素写为指定值 `v`

一些算法接受两个迭代器范围，同时对两个序列进行遍历操作，比如 `equal(range1, range2)`，比较两个序列是否相等（这类接受两个序列的算法，需要保证第二个序列的长度大于等于第一个序列）

一些算法可选择性接受一个可调用对象来实现自定义操作，比如排序和去重算法

- `sort(range, [com])`，对指定范围内的元素进行排序，若没有提供比较器 `com` 则默认升序
- `stable_sort(range, [com])`，稳定排序版本
- `unique(range, [com])`，对指定范围内的元素去重排序，使不重复的靠前，并返回最后一个不重复元素的下一个位置，若没有提供比较器 `com` 则默认使用 `==` 比较

> 写操作算法不检查范围合法性，开发者需确保写范围未越界

### lambda 函数

lambda 函数和普通函数、函数指针一样都是==可调用对象==，可以理解为一个匿名的内联函数，其形式如下

- `[captures]`，捕获列表，与闭包相关
- `(params)`，参数列表，如果是无参函数可以整个省略
- `R`，返回类型，如果函数体只有一条语句则省略并由编译器推断

```c++
/*
[captures](params) -> R {
	// 函数体
}
*/
auto compare = [](const string &a, const string &b) -> bool {
  return a.size() < b.size();
};
```

当 lambda 出现在函数中时，lambda 内部只能访问捕获列表中指示的局部变量。局部变量的捕获方式分为==值捕获==和==引用捕获==，分别对应值传递和引用传递，两种捕获方式可以同时存在

```c++
int main() {
	int num = 1;
	string s = "1";
  // 其中 num 为值捕获、s 为引用捕获
	auto lambda1 = [num, &s] {return num + stoi(s);}
  // num 值捕获，其他推断为引用捕获 
  auto lambda2 = [&, num] {}
  // s 引用捕获，其他推断为值捕获
  auto lambda3 = [=, &s] {}
  // 可变 lambda 可以在 lambda 内部修改值捕获的变量
  auto lambda4 = [num] mutable {++num;}
}
```

也可以不指明要捕获的变量，在捕获列表的头部放置 `=/&` 来让编译器自动推断需要捕获的变量，称为==隐式捕获==，隐式捕获和具名捕获可以同时存在，但是具名捕获列表必须位于 `=/&` 之后

lambda 值捕获的变量默认是不可写的，如果有写的需要，需要在参数列表后加上 `mutable` 关键字将其变为可变 lambda

> 如果使用引用捕获，需确保 lambda 执行时引用捕获的变量存在 -> 函数不能返回带有引用捕获的 lambda（同样适用于值捕获的指针/迭代器）

### bind 函数

标准库提供的 `bind(callable, arg_list)` 接受一个可调用对象 `callable` 和参数列表 `arg_list`，并返回一个新的可调用对象 `newCallable`，可实现目标可调用对象上的参数绑定（闭包）和参数重排

`bind` 的参数列表 `arg_list` 在参数顺序上对应着 `callable` 的参数顺序，`arg_list` 中可以包含具体要绑定的实参，也可以包含形如 `_n` 的==占位符==（位于 `std::placeholders` 空间下）

占位符用于表示 `newCallable` 对应位置的参数（比如 `_1` 表示 `newCallable` 的第一个参数），`arg_list` 中有多少个占位符就说明新的调用对象入参有多少个

```c++
bool compare(string &a, string &b) {
	return a.size() < b.size();
}
// 参数绑定：为 compare 的第一个参数绑定字符串 "abc"，compare1 的第一个参数传递给 compare 的第二个参数
auto compare1 = bind(compare, "abc", _1); // compare1("def") 等价于 compare("abc", "def")
// 参数重排：交换两个参数的身份
auto compare2 = bind(compare, _2, _1); // compare2(a, b) 等价于 compare(b, a)
```

`bind` 绑定的实参默认是按值传递的，如果需要按引用传递，需要使用 `ref/cref()` 包装实参以按引用/常量引用的方式传递如 `bind(compare, ref(str), _1)`


### 迭代器

虽然算法不能直接操作容器只能操作迭代器，但如果让迭代器上的操作和容器上的操作建立关系，就可以让算法间接的操作容器。==插入迭代器==就属于这类迭代器（解引用符被重载），对其进行解引用赋值时，等价于对其绑定的容器进行相关操作。比如 `back_inserter(c)` 可以获取容器上的==尾插迭代器==，对尾插迭代器的接引用赋值等价于对容器进行 `push_back()`

```c++
vector<int> vec;
// 获取容器的尾插迭代器
auto it = back_inserter(vec);
// 等价于 vec.push_back(42)
*it = 42; 
// 继续往容器中添加 10 个 1
fill_n(it, 10, 1);
```

插入迭代器对于一些带写输出的算法很有用，这些算法通常会接受一个目标迭代器作为写输出的起始位置，这通常要求目标迭代器之后的大小不小于源序列；如果使用尾插迭代器充当目标迭代器，就可以将算法的直写操作转换为 `push_back()` 调用，完成空间的自动扩张 

```c++
// 源
vector<int> vec({1, 2, 1});
// 目标
vector<int> vec_copy;
vector<int> vec_replace;
// 将 vec 中的元素拷贝输出到 vec_copy
copy(vec.cbegin(), vec.cend(), back_inserter(vec_copy));
// 将 vec 中的 1 替换为 2，并将一份拷贝输出到 vec_replace
reeplace_copy(vec.cbegin(), vec.cend(), back_inserter(vec_replace), 1, 2);
```

