## IO

基础类型、部分复合类型以及部分容器实现了输出运算符 `<<` 和输入运算符 `>>`，可以便捷的往流中写入数据或从流中读取数据。输入运算符在每次读取时会跳过前导空白，在存在内容后以空白字符为读取结束的标记，并把该**结束标记留在流中**

特别的对于表示字符串类型，还可以使用 `getline(is, strLike)` 来读取一行字符串，`getline` 每次读取以换行符为读取结束的标记，**读取并丢弃结束标记**

### 基础流

标准库头文件 `<iostream>` 提供了三种流基类，分别为==输入流 istream==、==输出流 ostream==和==读写流 iostream==，并在此基础上派生出==文件流==用于读写文件、==字符串流==用于读写字符串

最常使用的 `cin` 和 `cout` 分别属于基础输入流和基础输出流。标准库所有流都继承自基础流，这意味着对 `cin` 和 `cout` 对象的所有操作同样适用其他派生流对象，比如使用移位运算符进行读写、 `getline()` 读取一行等。此外所有流都共享如下成员

| 成员 | 描述 |
| ------------- | ---- |
| s.badbit, s.bad() | 崩溃标记（系统级别，不可恢复）及崩溃判断 |
| s.failbit, s.fail() | 失效标记（操作失败导致）及失效判断 |
| s.eofbit, s.eof() | 尾部标记及尾部判断 |
| s.goodbit, s.good() | 生效标记及生效判断 |
| s.clear() | 重置所有标记位 |
| s.rdstate() | 返回流的状态（标记快照） |
| s.setstate(isolate flags) | 将流设置为指定状态 |

流一旦发生错误（比如执行了一个不支持的操作）或者到达尾部，流的 `failbit` 就会被置位并且进入失效状态，后续对流的操作都将失效。**失效状态的流在条件表达式中会隐式的转换为 `false`，因此可以将流本身或者返回流的表达式作为判断条件**

输出流维护着一个缓冲区用于暂存写入的数据，并且在缓冲刷新时执行真正的输出操作。程序正常结束以及缓冲区满时会自动刷新缓冲区，开发者也可以使用操纵符 `flush`（只刷新）、`endl`（输出换行并刷新）或 `ends`（输出空字符并刷新）来显式的刷新缓冲区；若想在每次写操作后自动刷新，也可以使用操纵符 `unitbuf`

> 和数组、函数类似，**流对象无法被拷贝**

### 文件流

头文件 `<fstream>` 提供的文件流允许开发者流式的读写文件，包括==ifstream（读）==、==ofstream（写）==和==fstream（读写）==三种类型，其特有的成员如下

| 成员                            | 描述                                          |
| ------------------------------- | --------------------------------------------- |
| fstream()                       | 默认构造函数，构造一未绑定文件的流            |
| fstream(string path)            | `explicit` 构造函数，构造一个绑定指定文件的流 |
| fstream(string path, mode mode) | 以指定模式构造一个绑定指定文件的流            |
| fs.open(string path)            | 将流绑定到指定文件                            |
| fs.close()                      | 取消流绑定的文件                              |
| fs.is_open()                    | 判断流是否成功绑定到文件                      |

文件流在读写之前必须绑定文件，流和文件是一对一的绑定关系，在绑定其他文件之前必须确保流是未绑定状态，**重复绑定或绑定失败会导致文件流 `failbit` 置位并进入失效状态**。文件流对象被销毁时会自动调用 `close()` 完成解绑，如果没有重复绑定的需要 `close()` 通常是不需要的手动调用的

文件流绑定文件时可以指定==文件模式==，对应参数中的 `mode`

- `in`-以读方式打开
- `out`-以写方式打开（隐含 `trunc`）
- `app`-尾部追加写（隐含 `out`，但是排除 `trunc`）
- `trunc`-截断模式（覆盖原文件内容）
- `ate`-读写前定位到文件末尾
- `binary`-以二进制方式读写

每种文件模式都是以二进制的形式表示占位，使用多个模式需使用逻辑或运算符 `|` 拼接。未指定模式的的流会采用流的默认模式，`ifstream` 的默认模式是 `in`；`ofstream` 的默认模式是 `out`；`fstream` 的默认模式是 `in | out`

### 字符串流

头文件 `<sstream>` 提供的字符串流允许开发者流式读写字符串数据，包括==istringstream（读）==、==ostringstream（写）==和==stringstream（读写）==三种类型，其特有的成员如下

| 成员              | 描述                                            |
| ----------------- | ----------------------------------------------- |
| sstream()         | 默认构造函数，构造一个空的流                    |
| sstream(string s) | `explicit` 构造函数，以指定字符串初始化流的内容 |
| ss.str()          | 以字符串的形式返回流的内容                      |
| ss.str(string s)  | 使用指定字符串填充流                            |

### 未格式化 IO

==未格式化 IO==允许把流作为一个无解释的字节序列进行读写操作

单字节操作

- `is.get([ch])`，从流中读取下一个字符并存入指定字符 `ch` 中，如果没提供 `ch` 则返回一个 `int` 整型表示读取的字符
- `is.peek()`，将下一个字符作为 `int` 返回，**该字符仍留在流中**
- `is.unget()`，将最后读取的字符回退到流中（将流后移一个位置）
- `is.putback(ch)`，将最后读取的字符回退到流中，`ch` 必须为最后读取的字符
- `os.put(ch)`，将指定字符写入流

多字节操作

- `is.get(cp, size, delim)`，读取 `size-1` 个字节或者遇到结束标记 `delim` 后停止，将读取到的内容存入字符数组 `cp`，**并在结尾自动追加空字符，结束标记留在流中**
- `is.getline(cp, size, delim)`，与上面的 `get` 函数一致，**但是读取并丢弃结束标记**
- `is.read(cp, size)`，从流中读取 `size` 个字节存入字符数组 `cp`，**不会在结尾自动追加空字符**
- `is.gcount()`，返回上次流操作读取的字节数
- `os.write(cp, size)`，将字符数组中的 `size` 个字符写入流

### IO 操纵符

输出流对象可以使用输出运算符接受一个==操纵符==来对输出进行格式化，如 `hex/oct/dec` 操纵符可以控制整型数据以什么进制展示，`showbase` 操纵符可以在其基础上显示进制标识

输出流对象上也存在一些成员方法可以控制输出的格式，比如 `cout.precision(n)` 可以控制浮点数显示的有效位数

> 一但指定了某种格式化，该格式就会一直生效，除非使用同类格式化进行覆盖

```c++
// 控制接下来的整型以十六进制展示，并且显示进制标识 0x
cout << hex << showbase;
cout << 12; // 0xc
// 控制接下来的浮点数显示 12 位有效数字
cout.precision(12);
cout << (1 / 7.0); // 0.142857142857
```

### IO 随机访问

在读写文件流或者字符串流的时候，实际上存在一个游标指示当前的位置，通过操纵游标可以实现在流的指定位置开始读写操作

函数名中的 `X` 取决于输入流（`X='g'`）还是输出流（`X='p'`）

- `s.tellX()`，返回当前游标的位置
- `s.seekX(pos)`，将游标定位到指定位置
- `s.seekX(offset, from)`，将游标定位到指定位置的偏移处，`from` 可以是 `S::beg/cur/end`，分别对应流的开头/当前/结尾位置 

