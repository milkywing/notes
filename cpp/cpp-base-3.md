## IO

### 基础流（`iostream` 头文件）

标准库提供了三种流基类，分别为==输入流 istream==、==输出流 ostream==和==读写流 iostream==，并在此基础上派生出==文件流==用于读写文件、==字符串流==用于读写字符串，像最常使用的 `cin` 和 `cout` 就分别属于基础输入流和基础输出流。标准库所有流都继承自基础流，这意味着对 `cin` 和 `cout` 对象的所有操作同样适用其他派生流对象，比如使用移位运算符进行读写、 `getline()` 读取一行等。所有流都可以使用如下成员

| 成员 | 描述 |
| ------------- | ---- |
| stream::badbit, bool stream::bad() | 崩溃标记（系统级别，不可恢复）及崩溃判断 |
| stream::failbit, bool stream::fail() | 失效标记（操作失败导致）及失效判断 |
| stream::eofbit, bool stream::eof() | 尾部标记及尾部判断 |
| stream::goodbit, bool stream::good() | 生效标记及生效判断 |
| void stream::clear() | 重置所有标记位 |
| isolate stream::rdstate() | 返回流的状态（标记快照） |
| void stream::setstate(isolate flags) | 将流设置为指定状态 |

流一旦发生错误（比如执行了一个不支持的操作）或者到达尾部，流的 `failbit` 就会被置位并且进入失效状态，后续对流的操作都将失效。**失效状态的流在条件表达式中会隐式的转换为 `false`，因此可以将流本身或者值为流的表达式作为判断条件**

输出流维护着一个缓冲区用于暂存写入的数据，并且在缓冲刷新时执行真正的输出操作。程序正常结束以及缓冲区满时会自动刷新缓冲区，开发者也可以使用操纵符 `flush`（只刷新）、`endl`（输出换行并刷新）或 `ends`（输出空字符并刷新）来显式的刷新缓冲区；若想在每次写操作后自动刷新，也可以使用操纵符 `unitbuf`

> 和数组、函数类似，**流对象无法被拷贝**

### 文件流（`fstream` 头文件）

文件流允许开发者流式的读写文件，包括==ifstream（读）==、==ofstream（写）==和==fstream（读写）==三种类型，其特有的成员如下

| 成员                                     | 描述                                          |
| ---------------------------------------- | --------------------------------------------- |
| fstream::fstream()                       | 默认构造函数，构造一未绑定文件的流            |
| fstream::fstream(string path)            | `explicit` 构造函数，构造一个绑定指定文件的流 |
| fstream::fstream(string path, mode mode) | 以指定模式构造一个绑定指定文件的流            |
| void fstream::open(string path)          | 将流绑定到指定文件                            |
| void fstream::close()                    | 取消流绑定的文件                              |
| bool fstream::is_open()                  | 判断流是否成功绑定到文件                      |

文件流在读写之前必须绑定文件，流和文件是一对一的绑定关系，在绑定其他文件之前必须确保流是未绑定状态，**重复绑定或绑定失败会导致文件流 `failbit` 置位并进入失效状态**。文件流对象被销毁时会自动调用 `close()` 完成解绑，如果没有重复绑定的需要 `close()` 通常是不需要的手动调用的

文件流绑定文件时可以指定==文件模式==，对应参数中的 `mode`

- `in`-以读方式打开
- `out`-以写方式打开（隐含 `trunc`）
- `app`-尾部追加写（隐含 `out`，但是排除 `trunc`）
- `trunc`-截断模式（覆盖原文件内容）
- `ate`-读写前定位到文件末尾
- `binary`-以二进制方式读写

每种文件模式都是以二进制的形式表示占位，使用多个模式需使用逻辑或运算符 `|` 拼接。未指定模式的的流会采用流的默认模式，`ifstream` 的默认模式是 `in`；`ofstream` 的默认模式是 `out`；`fstream` 的默认模式是 `in | out`

### 字符串流（`sstream` 头文件）

字符串流允许开发者流式的读写字符串数据，包括==istringstream（读）==、==ostringstream（写）==和==stringstream（读写）==三种类型，其特有的成员如下

| 成员                        | 描述                                            |
| --------------------------- | ----------------------------------------------- |
| sstream::sstream()          | 默认构造函数，构造一个空的流                    |
| sstream::sstream(string s)  | `explicit` 构造函数，以指定字符串初始化流的内容 |
| string sstream::str()       | 以字符串的形式返回流的内容                      |
| void sstream::str(string s) | 使用指定字符串填充流                            |

## 顺序容器

容器指的是特定类型对象的集合，包括==顺序容器==和==关联容器==两类，容器都是模板类（泛型），定义在对应的同名头文件中。碍于篇幅限制，这里先介绍顺序容器

顺序容器提供了控制元素存储和访问顺序的能力，主要分成四大类，可根据实际场景选用

- 数组：包括==不定长数组 vector==、==定长数组 array==，可随机访问
- 队列：只有==双端队列 deque==，可随机访问，在两端插入/删除性能高
- 链表：包括==双向链表 list==、==单向链表 forward_list==，不支持随机访问，任意位置插入/删除性能高
- 字符串：只有==不定长字符串 string==，可随机访问

> 和数组一样，**`array` 的大小是类型的一部分**，由第二个泛型参数指明，如 `array<int, 10> a;`

### 容器共有操作

下面介绍顺序容器和关联容器的共有操作，非共有操作会特别提示

#### 共有类型成员

- `C::iterator/const_iterator`，容器的正向迭代器类型
- `C::reverse_iterator/const_reverse_iterator`，容器的反向迭代器类型
- `C::difference_type`，有符号整型，用于表示两个迭代器之间的距离
- `C::size_type`，无符号整型，用于表示容器大小
- `C::value_type`，元素类型
- `C::reference/const_reference`，元素左值引用类型

#### 共有构造函数

- `C()`，默认构造函数
  - 对于 `array`，构造对应大小，元素默认初始化的容器
  - 对于非 `array`，构造空容器

- `C(c)`，以指定容器为原本构造副本容器，容器类型必须严格相等
- `C(ib, ie)`，以迭代器范围 `[ib, ie)` 中的值为初始元素构造容器**（`array` 不适用）**
- `C(il)`，以初始化列表中的值为初始元素构造容器

容器进行赋值拷贝时（对应构造函数 `C(c)`），两者容器类型必须严格相等；但如果是通过迭代器范围或初始化列表的形式拷贝（对应构造函数 `C(ib, ie)` 和 `C(il)`），只要元素类型能转换，不强求容器类型相等

```c++
vector<double> vd = {1, 2, 3};
vector<int> vi1(v2.begin(), v2.end()); // 正确，浮点类型可转换为整型
vector<int> vi2 = vd; // 错误，拷贝赋值时，容器类型必须严格相等（包括元素类型）
```

另外还有两个构造函数为顺序容器共有（除去 `array`），用于在构造时指定容器大小

- `C(n)`，构造大小为 `n`，元素默认初始化的容器**（`string` 不适用）**
- `C(n, v)`，构造大小为 `n`，元素都为 `v` 副本的容器

#### 共有赋值操作

- `swap(c1, c2)/c1.swap(c2)`，交换两个容器的元素，通常会比赋值拷贝快
- `c.assign(ib, ie)`，将容器中的元素替换为迭代器范围 `[ib, ie)` 中的值副本
- `c.assign(il)`，将容器中的元素替换为初始化列表中的值副本
- `c.assign(n, v)`，将容器中的元素替换为 `n` 个 `v` 副本

> `assign` 操作会使容器内的迭代器、引用和指针失效，但是 `swap` 操作不会（因为 `swap` 只交换的两个元素的数据结构，元素本身并没有移动，`string` 除外）
>
> `assign` 操作不适用于定长 `array` 和关联容器

#### 共有大小操作

- `c.size()`，获取容器元素数量**（`forward_list` 不支持）**
- `c.max_size()`，获取容器能承载的元素数量上限
- `c.empty()`，判断是否为空容器

#### 共有比较操作

所有容器都支持相等运算符（`== / !=`），除了无序关联容器的容器都支持关系运算符（`> / >= / < / <=`）

容器比较操作的实质是对元素进行逐个比较，**因此容器能比较的前提是元素支持对应的比较操作**（容器的相等性比较需要元素实现 `==`，容器的大小性比较需要元素实现 `<`）

> 容器比较要求两个容器类型严格相等

#### 共有元素操作

- `c.insert(args)`系列函数，将指定的若干个副本插入到容器的指定位置
- `c.emplace(inits)`系列函数，构造一个元素插入到容器的指定位置
- `c.erase(args)`，删除指定元素
- `c.clear()`，清空容器

> 部分容器会因为自身特性导致无法支持部分操作，或者入参定义不一样

### 顺序容器操作

#### 添加元素

添加元素操作可以分成三类

- 头部插入，`c.push_front(v)/c.emplace_front(inits)`，在头部插入指定元素 `v` 或者以 `inits` 构造元素插入到头部
- 尾部插入，`c.push_back(v)/c.emplace_back(inits)`，在尾部插入指定元素 `v` 或者以 `inits` 构造元素插入到尾部
- 指定位置插入（返回指向第一个加入元素的迭代器）
  - `c.insert(ip, v)`，在指定位置 `ip`（迭代器，下同）之前插入指定元素 `v`
  - `c.insert(ip, n, v)`，在指定位置之前插入 `n` 个指定元素 `v`
  - `c.insert(ip, ib, ie)`，在指定位置之前插入迭代器范围 `[ib, ie)` 中的元素
  - `c.insert(ip, il)`，在指定位置之前插入初始化列表 `il` 中的元素
  - `c.emplace(ip, inits)`，以 `inits` 构造元素插入到指定位置之前

> 对于 `vector`、`string` 和 `deque`（空间是连续的容器）来说，执行插入/删除操作会导致容器内的迭代器、引用和指针失效

#### 删除元素

#### 访问元素



迭代器操作

- `begin/cbegin()`，获取指向首元素的迭代器
- `end/cend()`，获取指向尾后元素的迭代器





