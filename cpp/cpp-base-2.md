## 类基础

### 类的基础构成

使用关键字 `struct` 或 `class` 来定义类，两种定义方式只在默认访问控制上存在差别，`struct` 成员默认是 `public` 的，而 `class` 成员默认是 `private` 的。类中也可以通过访问说明符 `public、private、protected` 显式的说明成员的访问级别

类定义由数据成员的定义和成员函数的声明、定义组成

- ==数据成员==在类内定义时可指定类内初始值，无类内初始值则默认初始化
- ==成员函数==的声明需要在类内部，定义既可以在类内部也可以在类外部
  - **定义在内部的函数本身就是声明，并且是隐式内联的**；若想让定义在外部的函数内联，可以在外部定义时加上 `inline` 关键字
  - 函数内部可以通过隐式参数 `this` 指针访问调用函数的对象（即 `this` 指针指向类的实例对象，`*this` 是实例对象的引用）
  - 函数内部可以直接访问成员，也可以通过 `this` 显式的访问成员
  - 在函数声明和定义的参数列表后加上 `const` 限定符来指示==常量成员函数==，**常量成员函数内的 `this` 指针是底层 `const`，无法修改实例上的成员，只能只读的访问数据成员和调用常量成员函数**（常量对象的引用和指针同理）

### 构造函数

==构造函数==是和类名同名的函数（可以理解为特殊的成员函数），在类对象创建时执行，负责控制类对象的初始化过程。构造函数声明和定义时无需指定返回类型，且不能是 `const` 的

**仅在类没有声明任何构造函数时，编译器才会自动合成默认构造函数**负责为无类内初始值的数据成员执行默认初始化。若在声明了其他构造函数的同时也想使用默认构造函数，需要显式的请求编译器合成默认构造函数（在默认构造函数声明后接 `= default`）

构造函数的形参列表和函数体之间可以插入==初始值列表==，负责在执行函数体之前利用形参初始化数据成员

构造函数的形参列表和函数体之间还可以插入==委托构造函数==，即在执行函数体之前将自己的部分/全部初始化工作委托给另一个构造函数

一个单参数构造函数暗含着隐式类型转换，即可以将形参类型的值当作类类型使用，编译器会自动以前者为实参调用构造函数来创建一个类对象完成一次隐式类型转换。要想阻止这种隐式转换，可以将构造函数声明为 `explicit`（在声明语句前加上 `explicit` 关键字），使得 `explicit` 构造函数只能用于直接初始化

> 复合数据类型不适合由默认构造函数初始化
>
> 只有类的所有数据成员的类型都有默认构造函数时，类才能合成默认构造函数
>
> **类数据成员的初始化发生在构造函数体之前**，对于常量数据成员，要么定义时指定了类内初始值，要么只能在初始值列表中初始化
>
> **`explicit` 关键字只能在声明中使用，不能在定义中使用**


下面是一段展示类定义的代码

```c++
class Vec {
public:
  // 类内声明构造函数
  Vec();
  Vec(double x, double y);

  // 类内声明常量成员函数 Length
  double Length() const;

  // 类内定义成员函数，自动内联
  double x() {
    return x_;
  }
  double y() {
    return y_;
  }

private:
  // 数据成员，由构造函数负责初始化
  double x_, y_;
};

// 类外定义构造函数，请求编译器合成默认构造函数
Vec::Vec() = default;
// 类外定义构造函数，使用初始化列表初始化数据成员
Vec::Vec(double x, double y): x_(x), y_(y) {}

// 类外定义常量成员函数 Length
double Vec::Length() const {
  return std::sqrt(x_ * x_ + y_ * y_);
};
```

类除了要控制初始化，还需要控制拷贝、赋值、销毁行为，后三者统称为类的==拷贝控制==，由专门的函数负责。在没有声明相应的拷贝控制函数的情况下，编译器会自动合成相应的默认拷贝控制函数负责管理成员对象的拷贝、赋值和销毁行为。更多拷贝控制的知识将在后面介绍

> 合成的默认拷贝控制函数只能管理类中的自动对象，如果涉及动态内存分配，应该由开发者负责管理拷贝控制

### 友元

类的私有成员默认情况下只能类内访问，若想让类外的其他类或函数访问，可以在类内将外部类或函数声明为==友元==（在声明语句前加上 `friend` 关键字）

需要注意的是，友元的声明只是说明了外部函数的访问权限，并不是真正的函数声明，外部函数真正的声明还是在类外部

```c++
class Vec {
	// 声明友元函数 print，友元函数可以直接访问私有数据成员 x_、y_
	friend void print(Vec);
};
// 友元函数真正的声明
void print(Vec);
```

一个类指定了友元类，则友元类的可以访问此类的所有成员。此外也可以指定类的某个成员函数为友元，此时只有该成员函数可以访问此类的所有成员

```c++
class Vec {
	// 对于 Triangle 类，只有 scale 成员函数才能访问 Vec 的私有成员
	friend void Triangle::scale(double);
}
```

### 类的其他特性

可以在类内定义==类型成员==，供类内部直接使用或类外部引用，容器类的 `size_type` 类型就属于类内类型成员。**类型成员必须先定义后使用，通常放在最开头**

```c++
class Vec {
public:
	typedef int size_t;
};
```

在数据成员的定义语句前加上 `mutable` 关键字来定义==可变数据成员==，可变数据成员总是可写的，无视常量成员函数的限制

在声明语句前加上 `static` 关键字来声明类的==静态成员==，静态成员与类直接相关，独立于所有实例对象且被所有实例对象共享

- 与类直接相关，意味着可以通过类名作用域运算符直接访问非私有静态成员
- 独立于所有实例对象，意味着**静态成员函数中无法使用 `this` 并且只能访问其他静态成员**
- 被所有实例对象共享，意味着在普通成员函数中可以直接访问所有静态成员，**静态数成员也可以作为成员函数的默认实参**

```c++
class Vec {
public:
	static int static_var_;
	static int static_fun();
};
// 静态成员必须在类外部定义或初始化
int Vec::static_fun() {
	return 233;
}
int Vec::static_var_ = static_fun();
```

> **和 `explicit` 一样，`static` 关键字只能在成员函数声明中使用，不能在定义中使用**
>
> 一般情况下，静态成员必须在类外定义或初始化

### 类的作用域

类本身就是一个作用域，类外定义的成员函数因为指定了所属的类作用域，整个成员函数体都相当于在类作用域中，类内声明的名字在函数体中都是可见的；而成员函数的返回类型出现在指定之前，因此成员函数定义中的返回类型不在类作用域之中，返回类型若想使用类中的名字，需要单独指定所属类的作用域

```c++
// 成员函数定义中的返回类型不在类作用域之中
Vec::size_t
Vec::TrunLength() const {
	return std::sqrt(x_ * x_ + y_ * y_);
}
```

> 在成员函数中，名字查找顺序为：函数体内 -> 所属类内 -> 函数定义之前的作用域内

## 动态内存

动态内存，或称堆内存，是存放动态分配对象的地方，这些动态对象在在运行时由程序显式的创建（`new`），不再使用时由程序显式的销毁（`delete`），动态对象在堆中被分配的内存是无名的，因此必须基于指针来管理动态对象

直接管理动态内存是件很费神且高风险的，忘记释放内存会导致内存泄漏，提前释放任被引用的内存会导致非法访问。更多情况下，应该使用 `memory` 头文件中的智能指针来管理动态内存

### 直接管理内存

使用 `new` 运算符来为对象分配动态内存，返回指向该对象的指针

```c++
// 动态分配的整型对象，默认初始化，其值未定义
int *pi1 = new int;
// 动态分配的整型对象，值初始化为 0
int *pi2 = new int();
// 动态分配的字符串对象，直接初始化为 “1024”
string *ps = new string("1024");
```



### 智能指针





## 拷贝控制
