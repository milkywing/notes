## 类基础

### 类的基础构成

使用关键字 `struct` 或 `class` 来定义类，两种定义方式只在默认访问控制上存在差别，`struct` 成员默认是 `public` 的，而 `class` 成员默认是 `private` 的。类中也可以通过访问说明符 `public、private、protected` 显式的说明成员的访问级别

类定义由数据成员的定义和成员函数的声明、定义组成

- ==数据成员==在类内定义时可指定类内初始值，无类内初始值则默认初始化
- ==成员函数==的声明需要在类内部，定义既可以在类内部也可以在类外部
  - **定义在内部的成员函数本身就是声明，并且是隐式内联的**；若想让定义在外部的成员函数内联，可以在外部定义时加上 `inline` 关键字
  - 成员函数内部可以通过隐式参数 `this` 指针访问调用函数的对象（即 `this` 指针指向类的实例对象，`*this` 是实例对象的引用）
  - 类作用域内的成员函数可以直接访问成员（无需显式使用 `this`）
  - 在函数声明和定义的参数列表后加上 `const` 限定符来指示==常量成员函数==，**常量成员函数内的 `this` 指针是底层 `const`，无法修改实例上的成员，只能只读的访问数据成员和调用常量成员函数**（常量对象的引用和指针同理）

### 构造函数

==构造函数==是和类名同名的函数（可以理解为特殊的成员函数），在类对象创建时执行，负责控制类对象的初始化过程。构造函数声明和定义时无需指定返回类型，且不能是 `const` 的

**仅在类没有声明任何构造函数时，编译器才会自动合成默认构造函数**负责为数据成员的初始化。若在声明了其他构造函数的同时也想使用合成默认构造函数，需要显式的请求编译器合成默认构造函数（在默认构造函数定义后接 `= default`）

构造函数的形参列表和函数体之间可以插入==初始值列表==，在执行函数体之前利用形参初始化数据成员

构造函数的形参列表和函数体之间还可以插入==委托构造函数==，在执行函数体之前将自己的部分/全部初始化工作委托给另一个构造函数

一个单参数构造函数暗含着隐式类型转换，即可以将形参类型的值当作类类型使用，编译器会自动以前者为实参调用构造函数来创建一个类对象完成一次隐式类型转换。要想阻止这种隐式转换，可以将构造函数声明为 `explicit`（在声明语句前加上 `explicit` 关键字），使得 `explicit` 构造函数只能用于直接初始化

> 只有类的所有数据成员的类型都有默认构造函数时，类才能合成默认构造函数
>
> **数据成员的初始化发生在构造函数体之前**，对于常量数据成员，要么定义时指定了类内初始值，要么只能在初始值列表中初始化
>
> **`explicit` 关键字只能在声明中使用，不能在定义中使用**


下面是一段展示类定义的代码

```c++
class Vec {
public:
  // 类内声明构造函数
  Vec();
  Vec(double x, double y);

  // 类内声明常量成员函数 Length
  double Length() const;

  // 类内定义成员函数
  double x() {
    return x_;
  }
  double y() {
    return y_;
  }
private:
  // 数据成员，由构造函数负责初始化
  double x_, y_;
};

// 类外定义构造函数，请求编译器合成默认构造函数
Vec::Vec() = default;
// 类外定义构造函数，使用初始值列表初始化数据成员
Vec::Vec(double x, double y): x_(x), y_(y) {}

// 类外定义常量成员函数 Length
double Vec::Length() const {
  return std::sqrt(x_ * x_ + y_ * y_);
};
```

类除了要控制初始化，还需要控制拷贝、赋值、销毁行为，后三者统称为类的==拷贝控制==，由专门的函数负责。在没有声明相应的拷贝控制成员的情况下，编译器会自动合成相应的默认拷贝控制成员负责管理成员对象的拷贝、赋值和销毁行为。更多拷贝控制的知识将在后面介绍

> 合成的默认拷贝控制成员只能管理类中的自动对象，如果涉及动态内存分配，应该由开发者负责管理拷贝控制

### 友元

类的私有成员默认情况下只能类内访问，若想让类外的其他类或函数访问，需要将外部类或函数声明为==友元==（在声明语句前加上 `friend` 关键字）

需要注意的是，友元的声明只是说明了访问权限，外部函数真正的声明还是在类外部

```c++
class Vec {
	// 声明友元函数 print，友元函数可以直接访问私有数据成员 x_、y_
	friend void print(Vec);
};
// 友元函数真正的声明
void print(Vec);
```

一个类指定了友元类，则友元类的可以访问此类的所有成员。此外也可以指定外部类的某个成员函数为友元，此时只有该成员函数可以访问此类的所有成员

```c++
class Vec {
	// 对于 Triangle 类，只有 scale 成员函数才能访问 Vec 的私有成员
	friend void Triangle::scale(double);
}
```

### 类的其他特性

可以在类内定义==类型成员==，供类内部直接使用或类外部引用，容器类的 `size_type` 类型就属于类内类型成员。**类型成员必须先定义后使用，通常放在最开头**

```c++
class Vec {
public:
	typedef int size_t;
};
```

在数据成员的定义语句前加上 `mutable` 关键字来定义==可变数据成员==，可变数据成员总是可写的，无视常量成员函数的限制

在声明语句前加上 `static` 关键字来声明类的==静态成员==，静态成员与类直接相关，独立于所有实例对象且被所有实例对象共享

- 与类直接相关，意味着外部可以通过类名作用域运算符直接访问非私有静态成员
- 独立于所有实例对象，意味着**静态成员函数中无法使用 `this` 并且只能访问其他静态成员**
- 被所有实例对象共享，意味着在普通成员函数中可以直接访问所有静态成员，**静态数成员也可以作为成员函数的默认实参**

```c++
class Vec {
public:
	static int static_var_;
	static int static_fun();
};
// 静态成员必须在类外部定义或初始化
int Vec::static_fun() {
	return 233;
}
int Vec::static_var_ = static_fun();
```

> **和 `explicit` 一样，`static` 关键字只能在成员函数声明中使用，不能在定义中使用**
>
> 一般情况下，静态成员必须在类外定义或初始化

### 类的作用域

类本身就是一个作用域，类外定义的成员函数因为指定了所属的类，整个成员函数体都相当于在类作用域中，类内声明的名字在函数体中都是可见的。而成员函数的非尾置返回类型出现在指定之前，不在类作用域之中，返回类型若想使用类中的名字，需要单独指定所属类的作用域

```c++
// 成员函数定义中的非尾置返回类型不在类作用域之中
Vec::size_t
Vec::TrunLength() const {
	return std::sqrt(x_ * x_ + y_ * y_);
}
```

> 在成员函数中名字查找顺序为：函数体内 -> 所属类内 -> 函数定义之前的作用域内

### 类成员指针

==成员指针==是专门指向类非静态成员的指针（类的静态成员只需使用普通指针即可），定义成员指针需要在定义普通指针的基础上使用作用域运算符指明所属的类，如 `double Vec::*px`

和普通指针不同，**成员指针并不指向任何具体的对象，而是指向一个类成员（相当与一种身份）**。因此成员指针不能使用 `*` 直接解引用，而是要配合具体的类对象或类对象指针，使用 `.*/->*` 来访问成员指针指向的具体成员（绑定到实例对象上）

对类成员取址可以得到一个成员指针，用于给成员指针变量初始化或赋值，如 `double Vec::*px = &Vec::x_`

> 私有成员没办法在类外部获取到其成员指针，可以提供一个静态成员函数返回成员指针，在外部通过成员指针绕过访问控制访问私有成员

指向成员函数的成员指针称为==成员函数指针==，成员函数和成员函数指针不存在自动转换，因此给成员函数函数指针赋值和初始化或赋值时必须显式使用取址运算符。若成员函数存在重载，则无法通过初始化来自动推断成员函数指针的类型，必须显式指定类型供编译器匹配

> `.*/->*` 优先级很低，作用于成员函数指针时要用括号包起来，得到成员函数后再调用

```c++
Vec v, *pv = &v;

// 成员指针 px 可以指向 Vec 的浮点类型成员，初始化指向数据成员 x_（假设 x_, y_ 现在都是 public 的）
double Vec::*px = &Vec::x_;
// 自动推断成员指针类型为 double Vec::*
auto py = &Vec::y_;
// 解引用成员指针访问具体成员对象
cout << v.*px << pv->*px;

// 成员函数指针 pfun 可以指向 Vec 中 () => double 类型的成员函数，初始化指向成员函数 Length
double (Vec::*pfun)() const = &Vec::Length;
// .*、->* 运算符优先级很低，因此必须使用括号包裹解引用操作，得到成员函数再调用函数
cout << (v.*pfun)();
```

## 动态内存

动态内存，或称堆内存，是存放动态分配对象的地方，这些动态对象在在运行时由程序显式创建（`new`）和显式销毁（`delete`）。动态对象在堆中被分配的内存是无名的，因此必须基于指针来管理动态内存

直接管理动态内存是件高风险的活，忘记释放内存会导致内存泄漏，提前释放任仍被引用的内存会导致非法访问。更多情况下，应该使用智能指针来管理动态内存

### 直接管理内存

使用 `new` 运算符来为对象分配动态内存，分配的同时可执行初始化，返回指向该对象的内置指针。内存耗尽的情况下分配内存默认会抛异常，但可以在 `new` 后加上 `(nothrow)` 定位来阻止抛出异常转而返回空指针

使用 `delete` 运算符来销毁动态对象并释放对应的内存，**即便是动态分配的常量对象，也可以使用 `delete` 销毁**。内存被释放后，原本指向该内存的内置指针就会成为无效的==空悬指针==，因此 `delete` 操作后最好将其赋值为空指针

> **`delete` 的对象必须是指向动态内存的内置指针，同一块内存不能释放两次**

```c++
// 动态分配的整型对象，默认初始化，其值未定义
int *pi1 = new int;
// 动态分配的整型对象，值初始化为 0
int *pi2 = new int();
// 动态分配的字符串对象，直接初始化为 “1024”
string *ps = new string("1024");
// 动态分配常量字符串，空间不足时返回空指针
const string *pcs = new (nothrow) const string("1234");
// 销毁常量对象并释放内存
delete pcs;
```

`new` 还可以为多个对象分配动态内存，只要在类型说明符后加上 `[n]` 指示数量即可（`n` 可以是非常量），返回指向第一个对象的内置指针，这种为多个对象分配的连续内存称为==动态数组==。在释放动态数组时，需要在 `delete` 后加上 `[]`

```c++
// 分配大小为 3 的动态数组，并初始化为 1、2、3
int *pi = new int[3]{1, 2, 3};
// 释放动态数组
delete [] pi;
```

> **动态数组并不是数组类型，他是运行时分配的，其确切大小无法在编译阶段确定**，因此和无法像普通数组一样使用范围 `for`、`begin/end()`
>
> **分配和释放内存使用的运算符必须严格对应**，`new` 必须搭配 `delete`、`new T[n]` 必须搭配 `delete []`，禁止混用

### 智能指针

智能指针是内置指针的一个包装类，提供了更安全的动态内存管理方案，包括==共享指针 `share_ptr<T>`==、==独享指针 `unique_ptr<T, D>`==和==弱指针 `weak_ptr<T>`==

智能指针默认初始化为空智能指针，也可以初始化的时候绑定一个指向有效动态内存的内置指针；可以通过成员函数 `p.get()` 来获取智能指针中保存的内置指针；智能指针间可以通过 `swap()` 函数来交换保存的内置指针

> 如果智能指针释放了内存，先前通过 `p.get()` 获得的内置指针将成为无效的空悬指针，使用时要注意
>
> **空智能指针在条件表达式中会隐式的转换为 `false`，操作智能指针前可进行条件判断**
>
> 智能指针中除了弱指针和指向动态数组的独享指针，都支持解引用操作 `*` 和成员访问操作 `->`，等效于对内置指针的操作

#### 共享指针

共享指针会跟踪其指向对象的引用计数，并在引用计数归零或异常发生时默认使用 `delete` 来销毁对象并释放内存。成员函数 `sp.use_count()` 可以获取指向对象的引用计数，`sp.unique()` 可以判断指向对象的引用计数是否为 1

- 拷贝一个共享指针将递增源指针指向对象的计数（拷贝的形式可以是赋值、参数或返回值的值传递等）
- 当一个共享指针在赋值语句中被覆盖，或者因离开局部作用域等原因被销毁时，将递减指向对象的计数

创建共享指针除了定义时初始化绑定内置指针，还可以使用 `make_share<T>(inits)` 分配类型为 `T` 的动态对象并以 `inits` 初始化对象值（如果不传 `inits` 则进行值初始化），直接返回指向此对象的共享指针

```c++
auto sp1 = make_share<int>(1); // 值【1】计数为 1
auto sp2 = make_share<int>(2); // 值【2】计数为 1
sp1 = sp2; // 递增 sp2 指向对象的计数，递减 sp1 指向对象的计数，此时值【2】的计数归零被自动销毁并释放内存
```

**共享指针允许绑定指向非动态内存的指针，但必须提供自定义删除器**替代默认的 `delete`（因为指向非动态内存的指针无法 `delete`）。如 `share_ptr<T>(p, dfun)`，其中删除器 `dfun` 是一个 `(T*) -> void` 类型的可调用对象

此外，共享指针可以放弃当前绑定的内置指针转而绑定其他内置指针，如果放弃绑定后原内置指针的计数归零，将释放原内置指针指向的内存

- `sp.reset()`，放弃当前绑定，成为空共享指针
- `sp.reset(p, [dfun])`，放弃当前绑定，绑定新的内置指针，并且使用新的自定义删除器 `dfun`

> **一旦将内置指针交由共享指针托管后，就不应该再使用原来的内置指针**，因为原内置指针中的内存随时可能被释放成为空悬指针（这一点同样适用于 `p.get()`，除非确定使用时内存未被释放）

**共享指针不能直接管理动态数组，因为共享指针默认只会使用 `delete` 来释放内存，如果需要使用共享指针来管理动态数组，必须提供自定义删除器**。另外共享指针不支持下标索引操作，想要访问动态数组中的元素必须通过 `sp.get()` 获取内置指针，再通过内置指针访问

#### 独享指针

独享指针独占其绑定的内置指针，因此独享指针是不可拷贝的（作为函数返回值除外），独享指针被销毁时默认使用 `delete` 来释放指向的对象和内存

独享指针同样可以指定自定义删除器，但与共享指针通过函数参数指定的方式不同，独享指针还需通过第二个泛型参数指定删除器的类型。如 `unique_prt<T, D>(p, dfun)`，其中删除器 `D` 是删除器的类型，`dfun` 是删除器

> 这里可以看出，**共享指针是运行时绑定删除器，而独享指针是编译时绑定删除器**

独享指针的成员函数 `up.release()` 可以单纯的解绑并返回内置指针而不释放内存，自身变成空独享指针。`up.reset(p)` 则是放弃当前绑定的内置指针并释放内存，转而绑定其他内置指针

```c++
unique_prt<int> up1(new int(1)); // up1 绑定值【1】
unique_prt<int> up2(up1.release()); // up1 解绑值【1】，返回指向值【1】的指针，用于给 up2 绑定
up2.reset(new int(2)); // up2 解绑值【1】并释放其内存，转而绑定值【2】
up2.reset(); // up2 解绑值【2】并释放其内存
```

**独享指针可以直接管理动态数组**，当独享指针的类型为 `T[]` 时，说明管理目标是动态数组，在需要释放内存的时候会自动使用 `delete[]`。另外指向动态数组的独享指针不能使用成员访问操作，但是可以使用下标索引操作（只要不越界访问）

#### 弱指针

弱指针是一个比较特殊的智能指针，弱指针本身不负责内存的管理，只能绑定到一个共享指针上如 `weak_prt<T>(sp)`，并且不会影响指向对象的引用计数

真正管理着内存的是跟弱指针绑定的共享指针，因此弱指针不能直接访问指向的对象，弱指针上的操作实际上都是基于其绑定的共享指针

- `wp.use_count()`，返回绑定共享指针指向对象的引用计数
- `wp.expired()`，判断引用计数是否为 0
- `wp.lock()`，返回绑定的共享指针，如果共享指针已经释放了内存（`wp.expired()` 为 `true`），则返回空的共享指针

> 弱指针不支持指针访问操作，唯一访问弱指针指向对象的方式是 `wp.lock()` 获取绑定的共享指针，再通过共享指针访问

### allocator

直接管理动态内存时，分配内存的同时会构造对象，如果提供了初始值则根据初始值构造，没有提供初始值则进行值初始化构造，总之就是免不了构造操作，这会导致无法为没有默认构造函数的类类型分配动态内存

`allocator<T>` 类可以实现**内存分配和对象构造的分离**，`allocator` 可以分配一片原始的未构造内存，然后在内存上受控的构造对象

- `a.allocate(n)`，分配一片能容纳 `n` 个对象的原始内存，返回指向内存头部的指针
- `a.deallocate(p, n)`，释放指针 `p` 位置开始释放 `n` 个对象大小的内存（`p` 必须为分配内存时返回的指针，`n` 必须为分配内存指定的大小）
- `a.construct(p, inits)`，在指定位置以 `inits` 构造一个对象
- `a.destroy(p)`，销毁指定位置的对象（调用其析构函数）

> 在释放内存之前，需确保其上的对象已销毁。在销毁/访问对象时，需确保目标位置确实存在对象

利用如下算法，还可以批量在原始内存中构造对象

`uninitialized_copy(ib, ie, p)` 将迭代器范围 `[ib, ie)` 中的对象拷贝到 `p` 位置开始的原始内存中，返回指向最后对象的下一个位置的指针

`uninitialized_fill(pb, pe, v)` 原始内存范围 `[pb, pe)` 中填充 `v` 的拷贝，返回指向最后对象的下一个位置的指针

## 拷贝控制

### 拷贝控制成员-拷贝构造函数 & 拷贝赋值运算符

==拷贝构造函数==的第一个参数类型为自身类型的引用，无其他参数或其他参数都有默认值。当要使用一个对象来构造一个新对象时，拷贝构造函数将被调用，包括如下场景

- 数据源为同类型对象的直接初始化/拷贝初始化
- 非引用的参数传递和返回值传递

当类没有定义拷贝构造函数时，编译器会合成拷贝构造函数，合成拷贝构造函数会将给定对象的非静态成员拷贝到正在构造的对象中

==拷贝赋值运算符==接受自身类型的引用，并且返回自身类型的引用（通常指向等号左侧的对象，即 `*this`）。当使用赋值操作覆写某个变量时，拷贝赋值运算符将被调用

当类没有定义拷贝赋值运算符时，编译器会合成拷贝赋值运算符，合成拷贝赋值运算符会将等号右侧对象的非静态成员拷贝到左侧对象中

> 成员的类型决定了其拷贝方式：类类型成员会使用其拷贝构造函数/拷贝赋值运算符来拷贝，内置类型成员则直接拷贝
>
> 对于数组类型，合成拷贝函数/合成拷贝赋值运算符会逐个拷贝其中的元素

### 拷贝控制成员-析构函数

==析构函数==有且只有一个，形式为 `~ClassName()`，没有返回值，没有参数

局部非静态变量对象离开作用域时会被销毁；`delete/delete[]` 时动态对象会被销毁；容器或数组被销毁时其元素会被销毁；临时对象完成使命时会被销毁。当这些对象要被销毁时，析构函数将自动调用，在执完行函数体后销毁其非静态成员并释放内存

> **析构函数体自身不负责成员的销毁，成员的销毁发生在函数体之后的隐含析构阶段**

当类没有定义析构函数时，编译器会合成析构函数负责执行隐含的析构阶段。在不涉及动态内存直接管理的情况下，合成析构函数能很好的执行销毁工作，除非需在销毁时执行一段代码，通常是不需要定义自己的析构函数的

### 合成版本的限制

与默认构造函数类似，可以在拷贝控制成员定义后接 `= default` 来显式的请求编译器合成对应的拷贝控制成员

拷贝控制成员可以在定义后接 `= delete` 来显式的定义为删除的，被定义为删除的拷贝控制成员会阻止相关行为，就如 io 对象不能拷贝一样（其拷贝构造函数及拷贝赋值运算符被定义为删除的）

> 如果析构函数被定位为删除的，则该类不可用于实例化对象

无论是自动合成还是显式请求，合成版本的拷贝控制成员不一定都是可用的。如果一个类存在数据成员不能默认构造、拷贝、赋值或销毁（因成员类型对应的拷贝控制成员不可访问或被定义为删除的），则类对应的合成拷贝控制成员将被定义为删除的

> 如果类有 `const` 成员或引用成员，拷贝赋值运算符会被定义为删除的

### 拷贝控制与资源管理

通常，如果一个类要管理类外资源（如动态内存），则类必须定义自己的析构函数、拷贝构造函数和拷贝赋值运算符来负责资源的正确拷贝

作为例子，来考虑一个带有类外资源的类 `Hasptr`，该类有两个数据成员，一个整型 `i` 以及一个指向类外动态内存的字符串指针 `ps`。在拷贝和赋值的时候该类需要表现得像一个值，每个数据成员都要创建一个独立的副本资源，这意味着指针成员 `ps` 不能单纯的拷贝自身，而是要拷贝其指向的字符串。为了实现这种效果必须需要定义自己的拷贝控制成员

```c++
class HasPtr {
public:
  HasPtr(const string &s = string()): ps(new string(s)), i(0) {}
  // 拷贝构造函数，因为 ps 指向动态内存，拷贝时要为其分配新的内存并以副本进行初始化
  HasPtr(const HasPtr &h): ps(new string(*h.ps)), i(h.i) {}
  // 拷贝赋值运算符
  HasPtr& operator=(const HasPtr &);
  // 析构函数，负责释放动态内存
  ~HasPtr() {delete ps;}
private:
	// ps 指向动态内存
	string *ps;
	int i;
}

HasPtr& HasPtr::operator=(const HasPtr &h) {
  auto newps = new string(*h.ps); // 拷贝源字符串值并为其分配新的内存
  delete ps; // 释放原内存
  ps = newps; // 指向新的内存
  
  // 下面是错误的顺序，没考虑自己赋值给自己的情况，在 delete 后自身直接丢失了字符串值，h.ps 实际是空悬指针
  // delete ps;
  // ps = new string(*h.ps)
  
  i = h.i; // 非动态内存直接拷贝即可
  return *this; // 返回自身引用
}
```

> 拷贝赋值运算符通常会同时包揽拷贝构造函数（构造副本新资源）和析构函数（释放原有资源）的工作，可以将共享的部分抽离为一个私有工具函数
>
> **拷贝赋值运算符需要考虑并兼容自己给自己赋值的情况**，最佳的做法是在释放原内存指向新内存之前，先准备好存储了副本值的新内存

### 交换操作

要交换两个对象，除了引入一个临时对象然后赋值两次来完成，还可以借助 `swap()` 函数直接**交换两个对象底层指向**

标准库为所有算术类型和部分内置类型（如指针、数组、容器、智能指针等）提供了对应的 `swap` 重载，利用这些已有 `swap`，可以为自定义类定义其专属的 `swap` 逐一为数据成员执行交换操作

定义了 `swap` 的类，拷贝赋值运算符还有一种非引用入参的写法，省去不必要的手动内存分配

```c++
// 类的 swap 操作
void swap(HasPtr &l, HasPtr &r) {
  using std::swap;
  swap(l.ps, r.ps);
  swap(l.i, r.i);
}

HasPtr& HasPtr::operator=(const HasPtr h) {
	// 这里的 h 是值传递的副本，已经通过拷贝构造函数进行初始化
	// 和副本进行交换操作，交换完成后的 this 成了副本，原来的 h 已经没用了，在离开函数后被销毁
	swap(*this, h);
  return *this;
}
```

> 定义 `swap` 是一种优化手段，那些会重排元素顺序的算法会使用 `swap` 来交换元素
>
> 调用 `swap` 不应该使用限定（提前使用 `using` 声明），这样才能优先匹配自定义的 `swap`，然后再匹配内置 `swap`

### 左值引用 & 右值引用

==左值==和==右值==是表达式的两种对立的属性

- 左值，即某个对象的身份（在内存中的位置）
- 右值，即某个对象的值（内存上的值）

左值是有身份的存在（当然也有值），可以在代码中直接获取到对应的内存地址，多为定义的变量和引用，只要未离开其定义的作用域，左值都是可访问可修改的

右值是只有值的存在，无法在代码中直接获取到对应的内存地址，多为字面值和表达式求值过程的临时对象，只要离开了当条表达式就会被销毁

```c++
// 赋值运算的左侧必须是左值
int l = 1; // 定义的变量都是左值
l = 2; // 字面值都是右值，将左值 l 的底层指向直接重定向到右值 2（移动）
l = l + 1; // 算术运算结果是右值，将左值 l 的底层指向直接重定向到该结果（移动）
```

> 因为左值既有身份又有值，左值可以当右值使用，但反过来不行

绑定左值和右值的引用分别为==左值引用 &==和==右值引用 &&==，左右值引用限制了定义时绑定目标的左右值类型

```c++
int i = 0;
int &l = i; // 左值引用 l 绑定到左值上
int &&r = 123; // 右值引用 r 绑定到右值上
// 右值引用是左值，可以被修改，可以被左值引用绑定
r = 234; 
int &lr = r;
```

> 右值引用虽然绑定了右值，但因为赋予了身份，**右值引用其实是左值**

### 拷贝控制成员-移动构造函数 & 移动赋值运算符

根据右值的特性，右值引用总是指向一次性将要被销毁的对象。如果构造/赋值的源是一个右值引用，可以直接从右值引用接管底层值，免去副本构造的流程

考虑到左值可以当右值使用，标准库头文件 [`<utility>`](https://www.apiref.com/cpp-zh/cpp/utility.html) 提供了 `move()` 函数将一个左值转换为一个右值引用，一旦调用了 `move`，原左值就成了和右值一样的短命鬼，其值有可能会被别人接管，自身值不保，**因此 `move` 以后必须做出不读取源左值的保证**（销毁和写操作是允许的）

> 调用 `move` 应该始终使用限定如 `std::move()`

为了从右值接管值，需要定义==移动构造函数==和==移动赋值运算符==，其函数声明只需在拷贝构造函数和移动构造函数的基础上将入参类型改为右值引用即可

**移动构造函数和移动赋值运算符在接管了右值的底层值后，必须将右值置为可析构的状态**，因为移动完成后右值可能会被销毁

```c++
// 移动构造函数
HasPtr& HasPtr(HasPtr &&rh) noexcept : ps(rh.ps), i(rh.i) {
  rh.ps = nullptr; // 将右值置为可析构的状态
}
// 移动赋值运算符
HasPtr& HasPtr::operator=(HasPtr &&rh): noexcept {
  // 兼容自身赋值给自身的情况
	if(this != &rh) {
    i = rh.i;
    delete ps;
    ps = rh.ps;
    rh.ps = nullptr;
  }
}
```

移动操作接管已有内存而不分配新的内存，通常是不会抛出异常的。当移动构造函数或移动赋值运算符不会抛出异常时，必须标记为 `noexceot`（紧接参数列表）告知标准库，标准库只会使用做出了无异常保证的移动操作来优化，如果移动操作可能会抛出异常，标准库会转用拷贝操作来确保自身在异常发生时的不变性

当类没有定义任何拷贝控制成员，且其非静态数据成员皆可移动时，编译器会合成移动构造函数和移动赋值运算符，合成版本会将右值对象的非静态成员移动到目标对上

类定义了自己的移动构造函数，则合成版本的拷贝构造函数将是删除的，反过来也是如此（移动赋值运算符同理），因此**如果一个类定义了任一拷贝控制成员，就应该把其他的拷贝控制成员也定义了**

一个类既有拷贝构造又有移动构造函数，构造时具体使用哪个满足函数参数匹配的规则，即右值优先匹配移动构造，左值优先匹配拷贝构造（赋值运算符同理）。**如果对应的移动版本不可用，右值会使用拷贝版本作为替代（拷贝版本能安全的替代移动版本）**
