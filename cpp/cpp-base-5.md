## OOP

### 继承

定义类时在类名和类体之间插入==类派生列表==来说明要继承的类：类派生列表以冒号开头，后接要继承的带访问说明符的基类序列，如 `class A : public B {}`

作为基类，在声明成员函数时在开头加上 `virtual` 关键字可将该函数定义为==虚函数==，虚函数允许其派生类覆盖实现，并且虚函数在派生类中隐式的也是虚函数。非虚函数及数据成员则由派生类直接继承

作为派生类，通常需要覆盖基类的虚函数实现自己的版本，如果没有覆盖则直接继承基类的版本

派生类兼容基类，基类引用除了绑定自身类型，还可以绑定公有继承的派生类（指针同理），编译器会隐式的执行派生类到基类的类型转换。在这种情况下，==静态类型==为基类类型（在编译阶段已知），==动态类型==为实际绑定的基类或派生类（运行时才知）

> 派生类到基类的自动类型转换只对引用或指针生效，但如果基类存在可用的拷贝控制成员，纯类型的转换也是允许的，如 `b = a`
>
> 从基类到派生类的转换是禁止的，但是在确定安全的前提下可以使用强制类型转换绕开编译检查

派生类进行构造时，应该只负责自己部分的初始化工作，直接基类部分的初始化工作应该委托给直接基类构造函数，而不是在函数体中直接修改基类成员，如 `A(inits): B(inits) {}`

一个类如果不想被继承，可以在定义时在类名后追加 `final` 关键字，如 `class A final {}`

### 虚函数

通过普通类型调用虚函数，只会调用静态类型上的版本；只有通过引用/指针调用虚函数时，才会发生运行时的==动态绑定==，调用动态类型上的虚函数。动态绑定发生在运行时，编译阶段无法确定哪些虚函数会被调用，为了确保可用性，所有虚函数都需要有定义

> 如果虚函数调用使用了默认实参，则默认实参值由静态类型决定，与动态绑定无关

在使用基类引用/指针时，如果想绕过动态绑定机制直接调用继承链上指定类的虚函数，可以使用类名作用域运算符指定，如 `a->B::vfun()` 将绕过动态绑定机制，直接调用基类 `B` 上的虚函数

派生类如果覆盖基类的虚函数，两者的形参列表必须完全一致，返回值类型也必须一致（但返回自身类型的引用/类型是允许的）。在覆盖时，可以选择性的在参数列表后加上 `override` 关键字显式的说明覆盖行为，编译器会检查覆盖行为是否合法（覆盖目标是否为虚函数，两者类型是否匹配）

基类的虚函数如果不想被覆盖，参数列表后加上 `final` 关键字禁止覆盖

==纯虚函数==是没有定义实现的虚函数，在虚函数声明后接 `= 0` 来声明纯虚函数。含有未实现纯虚函数的类为==抽象基类/接口类==，抽象基类无法被实例化，只能被继承用于约束派生类的实现

### 访问控制

类成员三种访问控制级别

- ==公有 public==，无访问限制，外部和派生类中皆可访问
- ==私有 private==，只能在本类中访问
- ==受保护 protect==，外部和间接派生类不可访问，直接派生类中可访问（但是这种访问是必须是通过派生类对象本身进行的访问）

在继承时，基类成员的访问控制级别会被继承，派生列表中的访问说明符不会影响访问控制级别的继承，只会影响外部对基类部分的访问权限（`public` 继承时外部对基类部分访问权限遵循成员本身的访问控制级别，`private` 继承则所有基类部分成员外部都不能访问）

> `private` 继承的派生类在外部无法转换为基类

友元不会被继承，并且每个类负责控制自己部分成员的访问权限

- 基类的友元只能访问基类的成员，包括派生类的基类部分
- 派生类的友元只能访问本类独有的成员，不包括基类的部分

### 继承中的作用域

派生类的作用域实际上是嵌套在基类中的，名字查找顺着继承链由内到外进行，并且根据查找目标是否为虚函数来决定是否需要进行动态绑定

> 名字查找发生在类型检查之前，如果派生类和基类都定义了同名成员，基类的同名成员将被隐藏（包括所有同名重载函数）。要访问被隐藏的基类成员，可以使用类名作用域运算符指定

成员函数无论是否是虚函数都能被重载，受限于名字查找的规则，一个含有若干重载函数的的基类，派生类要么不覆盖，要么全覆盖，才能维持所有重载函数的可见性。如果派生类只想覆盖某一个重载函数又想维持所有重载函数的可见性，可以先将基类所有重载函数都引入当前作用域，然后再单独覆盖某一个重载函数

```c++
class B {
public:
	int fun(int);
	double fun(double);
}

class A : public B {
public:
	using B::fun; // 将基类所有重载函数都引入当前作用域
	int fun(int); // 单独覆盖第一个重载函数
}
```

### 继承中的拷贝控制

基类的析构函数应该是虚函数，这样在动态绑定的场景下才能使用正确版本的析构函数来控制销毁操作。如果析构函数是虚的，移动操作不会自动合成，必须由开发者显式定义

继承关系中的类各自负责自己部分的拷贝控制，对于合成的拷贝控制成员，以拷贝构造为例（其他拷贝控制成员同理），派生类执行自身拷贝构造函数会执行基类的拷贝构造函数，等待基类完成基类部分的拷贝构造后在继续自身部分的拷贝构造，形成一种由顶至底的拷贝构造顺序

> 析构的顺序是相反的，派生类隐式销毁完自己部分的成员并执行完自己的析构函数后，再去执行基类的析构工作，形成一种由底到顶的析构顺序

继承关系中的类各自负责自己部分的拷贝控制，对于自定义的拷贝控制成员同样成立，例如：派生类定义拷贝构造函数时应该将基类部分的初始化工作委托给基类构造函数；派生类定义拷贝赋值运算符时应该先执行基类的拷贝赋值运算符

> 如果基类的拷贝控制成员是删除的，则派生类对应的合成拷贝控制成员将被定义为删除的

## 模板泛型

==模板==能实现类型的参数化，让一段代码（通常是类或者函数）适用与不同的数据类型实现逻辑复用。模板定义通常放在头文件中，模板声明通常放在需要使用模板的代码之前

### 函数模板

模板声明/定义以 `template` 关键字打头，接着是尖括号包裹的==模板参数列表==，最后是平时的函数或类的声明/定义。==模板参数==首先可以是一个==类型参数==，每个类型参数前必须使用 `class` 或 `template` 关键字进行指示，类型参数可以当作类型说明符使用

调用函数模板时，可以显式的指定模板实参，也可以让编译器根据函数实参来推断模板实参。一组模板实参可以生成一个特定版本的函数，这称为函数模板的实例化

```c++
template <typename T>
T compare(const T &a, const T &b) {
  return a - b;
}

// 编译器根据函数的实参推断模板参数为 int，实例化 int compare(int, int)
compare(1, 2);
// 显式的指明模板参数为 double，实例化 double compare(double, double)
compare<double>(1, 2);
```

> 编译阶段中，模板定义本身并不会生成代码，只有实例化模板的一个特定版本才会生成代码
>
> 模板中使用的操作不一定所有类型都支持，这种不支持的操作会在编译阶段被检查出来并抛错，因此要尽可能使用类型无关的代码来编写模板

模板参数还可以是==非类型参数==，非类型参数表示一个值，可以当作一个常量值使用，非类型参数的实参只能是如下两种形式：

- 常量表达式整型
- 指向拥有静态生存期的对象或函数的指针或者左值引用

```c++
// 这里的 N 是非类型参数
template<typename T, size_t N>
array<T, N> &fill_arr(array<T, N> &arr, T val) {
  for(size_t i = 0; i<N; ++i) {
    arr[i] = val;
  }
  return arr;
}
// array 本身就是一个使用非类型参数的模板类例子
array<int, 4> arr{};
// 实例化 array<int, 4> &fill_arr(array<int, 4>, int)
fill_arr(arr, 8); // arr = {8,8,8,8}
```

> 类型参数和非类型参数可以混用

### 类模板

类模板的模板参数必须显式指定才能实例化，编译器为每个类模板实例生成一个独立的类，一个类模板的实例可以当成一个类类型使用

类模板内定义的成员函数可以直接使用模板参数，类模板外定义的成员函数则需要重新为函数说明类模板的模板参数。在类模板的作用域内，类模板名本身默认隐式带上模板实参，可以直接使用

> 实例化一个类模板并不会实例化其所有成员函数，一个类模板实例的成员函数只有在代码中被使用才会实例化

```c++
template <typename T>
class A {
	T funa(const T &);
  A& operator++(); // 在模板类的作用域内，使用类模板名本身可以省略模板实参，A 等效 A<T>
};
// 重新为类模板外定义的成员函数说明类模板的模板参数
template <typename T>
T A<T>::funa(const T &v) {return v;}
```

类模板可以声明友元，友元可以是一个模板或者模板实例

- 当友元是一个模板时，该友元模板的所有实例拥有对类模板所有实例的特殊访问权限
- 当友元是一个模板实例时，存在两种情况
  - 友元模板实参含类模板参数，只有模板参数对应的友元模板实例和类模板实例建立特殊访问关系
  - 友元模板实参不含类模板参数，只有该友元模板实例拥有对类模板所有实例的特殊访问权限

和普通类一样，类模板可以定义类型成员和静态成员；类模板每个实例都是一个独立的类，其静态成员也是独立的，需要通过模板实例作用域运算符访问，如 `A<int>::static_fun()`

无论是普通类还是类模板都可以定义==成员函数模板==，需要注意的是类模板的定义和成员函数模板的定义是独立的，他们的模板实参和实例化也是独立的

```c++
template <typename T>
class A {
  // 定义一个构造函数模板，专门适配各类容器的迭代器
  template <typename It> A(It b, It e);
}

// 类模板外定义成员函数模板，类模板参数说明在前，成员函数模板参数说明在后
template <typename T>
template <typename It>
A<T>::A(It b, It e) {}

vector<double> v{1,2,3};
A<int>(v.begin(), v.end()); // 类模板实参被指定为 int，成员函数模板实参被推断为 double
```

### 模板参数

使用作用域运算符访问模板参数上的类型成员时（假如该模板参数绑定了一个类类型），必须在前面加上 `typename` 关键字说明该名字是一个类型，用以与访问静态成员区分，如 `typename T::size_type size;`

在定义模板时可以指定默认模板实参，即便所有模板参数都有默认实参，使用默认实参显式实例化时的空尖括号也是不能省略的

```c++
template <typename T = int>
T compare(const T &a, const T &b) {
	return a - b;
}
// 显式实例化的尖括号不能省
compare<>(3, 4);
```

### 控制实例化

通常编译器会
