### TCP

> TCP（传输控制协议），一种**面向连接的**、**面向字节流的**、可靠的、传输层通信协议

对于应用层的数据报文，TCP 会把它们看作字节流进行拆分为多个 TCP 报文进行传输；对方收到后按序重新装配

#### TCP 三次握手建立连接

1. 客户端发送一个 SYN 报文，并指明客户端的初始序列号 ISN(c)
2. 服务端发送自己的 SYN 报文为应答，同样指明自己的初始序列号 ISN(s)，并将 ISN(c)+1 作为 ACK 数值
3. 客户端发送 ACK 报文，并将 ISN(s)+1 作为 ACK 数值

为什么要三次握手

- 两次握手的话，发送端可以确定自身和对方的发送/接收能力正常，但**接收端无法确定自身发送能力和对方接收能力**
- 两次握手的话，客户端有可能因为网络阻塞等原因会发送多个请求报文，**延时到达的请求又会与服务器建立连接，浪费服务器资源**

##### TCP 四次挥手断开连接

1. 客户端发送一个 FIN 报文，并指明客户端的序号
1. 服务端发送 ACK 报文应答，同样指明自己的序列号，并将客户端的序列号值 +1 作为 ACK 数值
1. 服务端无数据发送后，发送 FIN 报文，并指明服务端的序号
1. 客户端发送 ACK 报文应答，同样指明自己的序列号，并将服务端的序列号值 +1 作为 ACK 数值

客户端在发送最后一个 ACK 后等待 2MSL，为的是确保自己的 ACK 能被服务端接收到，如果服务端重传了 FIN，客户端能在等待的时间内捕捉到并重传 ACK

为什么四次挥手

- 客户端发送 FIN 报文后，表示客户端不再发送数据但是还能接受数据，此时**服务端可能还有数据传给客户端，因此 FIN 和 ACK 报文需要分开发送**

| 三次握手                                                     | 四次挥手                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![img](network.assets/fb489fc0-beb9-11eb-85f6-6fac77c0c9b3.png) | <img src="network.assets/0a3ebb90-beba-11eb-85f6-6fac77c0c9b3.png" alt="img" style="zoom:50%;" /> |

### UDP

> UDP（用户数据包协议），一种**面向数据报的通信协议**，利用 IP 提供**面向无连接**的通信服务

对于应用层的报文，UDP 只会加上首部，然后交给下面的网络层；对方收到后也会直接去掉首部交给上面的应用层

- UDP 不提供复杂的控制机制，自然没有丢包重传，乱序重排功能
- UDP 即收即发，不支持流量控制和拥塞控制

### HTTP

#### 常用状态码及请求头

常见状态码

- `100`等待剩余请求、`101`请求协议切换
- `200`、`201`已创建、`202`已接收正处理、`206`处理了部分请求（断点续传/大文件加载）
- `301`永久重定向、`302`临时重定向、`304`资源无修改
- `401`未授权、`403`禁止访问、`404`、`405`方法禁止、`406`不接受（无法满足accpet字段）、`408`超时
- `500`内部错误、`502`错误网关、`503`服务不可用、`504`网关超时

常见请求头

| 字段              | 说明             | 示例                              |
| ----------------- | ---------------- | --------------------------------- |
| accept            | 接受内容类型     | application/json                  |
| accept-charset    | 接受字符编码     | utf-8                             |
| accept-encoding   | 接受编码格式     | gzip,deflate                      |
| accept-language   | 接受的语言       | zh-CN                             |
| cache-control     | 缓存控制         | no-cache                          |
| connection        | 期望连接类型     | Upgrade                           |
| content-length    | 请求体长度       | 233                               |
| content-type      | 请求体mime类型   | application/x-www-form-urlencoded |
| cookie            | cookie           | var1='233'                        |
| date              | 请求发送时间     | Tue, 15 Nov 1994 08:12:31 GMT     |
| host              | 服务器域名和端口 | oshinonya.com                     |
| if-none-match     | 协商缓存策略     | 资源etag                          |
| if-modified-since | 协商缓存策略     | 资源最后修改时间                  |
| origin            | 跨域请求发起源   | https://oshinonya.com             |
| range             | 请求部分资源     | bytes=0-511                       |
| referer           | 请求的发起页面   | https://oshinonya.com             |
| user-agent        | 浏览器身份标识   | - -                               |

常见响应头

| 字段                                  | 说明                            | 示例                         |
| ------------------------------------- | ------------------------------- | ---------------------------- |
| access-control-allow-*                | 跨域设置                        | - -                          |
| cache-control                         | 缓存控制                        | public, max-age=3600         |
| content-disposition                   | 弹出下载框，指定文件名          | attachment;filename=“me.png” |
| content-encoding/language/length/type | 同上                            | - -                          |
| etag                                  | 资源标识符                      | - -                          |
| expires                               | 资源过期时间                    | - -                          |
| last-modified                         | 资源最后修改时间                | - -                          |
| location/refresh                      | 重定向/支持延迟的重定向         | https://oshinonya.com        |
| set-cookie                            | cookie设置                      | var1=‘2333’                  |


#### 浏览器缓存

分为强缓存和协商缓存，**强缓存优先级更高**

- **强缓存**，在客户端判断。客户端根据`cache-control`和`expires`字段（前者优先级更高）来判断资源是否命中强缓存
- **协商缓存**，在服务端判断。当强缓存没命中时，客户端通过`if-none-match`字段携带资源`etag`或`if-modified-since`字段携带资源`last-modified`发往服务端，由服务器指示客户端是否使用缓存（`304`）


#### GET 和 POST 的区别

- 知道`GET`请求参数放在`url`中（在地址可见），`POST`则放在`body`中
- `GET`请求参数只接收 ASCII 字符，`POST`无限制
- `GET`请求参数有长度限制，`POST`无限制
- `GET`请求会被浏览器主动缓存，`POST`不会，除非手动设置
- `GET`请求在浏览器中是 header、data 一并发送的，而`POST`一般会分开发送
- `GET`请求浏览器回退无害，`POST`会再次提交请求

#### HTTP的各个版本

HTTP1.0：

- 浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接

HTTP1.1：

- 引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用
- 虽然TCP连接被复用了，但是同一个TCP连接里面，所有的数据通信是按次序进行的
- 新增了一些请求方法（PUT、OPTIONS）
- 新增了一些请求头和响应头（缓存策略相关等）

HTTP2.0：

- 【二进制分帧】将请求和响应数据分割为多个帧，并采用二进制编码，帧之间可乱序发送
- 【多路复用】完全多路复用，一个连接里，双方都可同时发送多个请求或响应，而非有序并阻塞的
- 【首部压缩】双方都维护“首部表”记录之前 Header 键值对，下次发送只携带有差异的 Header
- 【服务器推送】服务器可以顺便把客户端接下来需要的资源一并推送

### HTTPS

> HTTPS = HTTP + TLS/SSL

HTTP 采用明文传输，所以中途容易被截获窥视篡改，而且收发双方不能确认对方的真伪

HTTPS 通过让 HTTP 运行在 SSL/TLS 协议上实现信息的加密、完整性校验和身份验证

- 客户端访问服务器建立SSL连接
- 服务端收到客户端请求后，将CA颁发的证书（证书中包含公钥）传送一份给客户端
- 客户端校验证书的数字签名，双方协商SSL连接的安全等级
- 客户端的浏览器根据安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给服务器
- 服务器利用自己的私钥解密出会话密钥
- 双方都有会话密钥了，开始加密通信


### 地址栏输入 URL 后发生的事

1. URL 解析
2. 根据域名进行 DNS 查询，获取目标服务器 IP 地址
3. 建立TCP连接
4. 发送HTTP请求
5. 服务器响应请求返回页面
6. 资源解析，渲染页面

展开【6】页面渲染过程

资源解析：

- 浏览器收到服务器响应的资源后，根据响应头做相应处理（如cookie设置，缓存等）
- 根据资源的`content-type`，使用不同的解析方式

页面渲染：

- 解析HTML、CSS，生成DOM树、CSS规则树
- 合并 DOM 树和 CSS 规则，生成 render 树
- 布局 render 树
- 绘制 render 树
- 将各层信息交给 GPU 进行合成，显示上屏
