### 小说新书架

#### 概念

书架的两个场景：主书架（展示用户整体收藏）、分组书架（展示分组构成）

场景显示/操作对象称为格子，格子承载的内容主要有两类，分别是书籍和分组，书籍和分组又有各自的子分类：

- 书籍
  - 普通书籍
  - 盗版书籍
  - 本地书籍
- 分组（由若干本书籍组成）
  - 普通分组
  - 盗版分组
  - 本地分组
  - 书单分组

场景的两个状态

- 常态（默认）：点击对象执行相应的跳转操作，长按对象呼出菜单
- 编辑态（点击编辑）：点击对象执行选中/取消选中操作，由菜单提供批量操作功能

菜单提供的操作

- 置顶
- 删除
- 移动（移回主书架、移动到新分组、移动到现有分组）

#### 基于二进制的编辑态模型

编辑态中菜单提供的操作功能不是一直都是可用的，某些特殊情况下某些操作会被禁用置灰并做相应提示，比如移动操作在用户选没有任何选中/选中数量过多时会禁用，在用户选中了本地分组也会被禁用。

> 目标：为两个不同的场景的编辑态提供统一的操作行为控制
>
> 问题：不同的操作对应的「特殊情况」不尽相同，即存在交叉部分，又存在各自独有的部分
>
> 排除方案：不可能为每个操作都硬编码 if-else 逻辑来实现可用性判断
>
> 解决方案：引入「特殊状态」和「状态集」的概念，参考 React lane 模型，使用二进制数表示「特殊状态」和「状态集」，方便进行目标状态的检查和优先级的计算

- 特殊状态（人为事先定义）：描述特定场景下，特定选中情况，使用某个位为1，其余位为0的二进制数表示，且1的位置越靠右，对应的优先级越高。比如在主书架内选中了本地分组，可以定义为一个特殊状态`0b1`；选中数量超过100本，也可以定义为一个特殊状态`0b10`。
- 状态集：因为支持多选，用户可能处于若干个特殊状态的叠加的状态，这些特殊状态的或结果就是状态集。在用户操作的过程中，实时根据场景和选中情况更新这个二进制数即可

有了状态集这个二进制数，就可以基于位运算方便的实现状态检查和优先级计算

为每种操作都定义一个 bitMask，表示各个操作需要关注的一些特殊状态。在计算状态可用性的时候，只需将状态集对应的二进制数和 bitMask 进行与运算，检查结果是否为 0 即可得知是否存在导致当前操作禁用的特殊状态。同时，从结果中提取最右方的 1 即可计算出最高优先级的特殊状态，用于获取相应提示



#### 手势事件屏蔽层

在主书架场景，页面是直接内嵌在 HippyFrame 容器中渲染的，容器的上下方是终端原生绘制区域，页面从容器上边界开始布局

在分组书架场景，页面是通过 Modal 渲染实现全屏效果的，页面从手机屏幕顶部开始布局

> 目标：准确获取用户点击位置，在点击位置附近弹出菜单，顺带解决安卓子组件超出父容器部分无法响应手势事件的问题
>
> 问题：不同场景、不同操作系统下，从原生手势事件中取到的坐标其参考系不尽相同
>
> 解决方案：在前端层屏蔽原生差异，统一坐标系，使得触点位置严格相对于页面的根容器

- 真机测试，发现 AND 上通过 Frame 容器渲染的页面，其手势事件触点参照系不符合要求，
- 针对这种特殊情况编写一个 formatter，对传入的原生事件进行
- 提供一个`TouchPointRecorder`组件，内部实现绑定 touchDown 手势事件，并

#### 弹窗逻辑抽象、复用、集中管理

书架中存在大量操作交互，不少交互存在二次确认/引导行为，涉及十余种弹窗，且部分弹窗间存在关联

> 目标：尽可能优雅的编写弹窗组件代码，尽可能优雅方式调起弹窗、向弹窗传递参数

弹出

将弹窗抽象为一下数据结构

```typescript
interface DialogMetaInfo {
  /** 弹窗唯一标识 */
  id: string;
  /** 弹窗组件 */
  component: React.FC<DialogCommonProps>;
    /**
   * 弹窗层叠优先级，越高越优先。
   * 若不提供，则自动为弹窗分配跟当前显示弹窗中最高的zIndex相等的值（即作为当前最高优插入）
   */
  zIndex?: number;
  /**
   * 注意：使用该属性前，请确保在弹窗组件中正确使用onAction回调埋点，否则不会生效
   * 可以导致弹窗关闭的弹窗行为。
   * 若不提供则默认Confirm/Cancel/Close/Blank行为会导致弹窗关闭
   */
  closeOnActions?: DialogAction[];
  /** 是否以Modal形式打开，默认否 */
  openWithModal?: boolean;
  /** 弹窗传参 */
  data?: Data;
}
```

### 小说频道性能优化

- 按照浏览器 performance API 实现大点工具库

- 根据渲染流程设计埋点方案

  - 有缓存：*TerminalInitial->AppInitial->LoadCache->Render*

  - 无缓存：*TerminalInitial->AppInitial->LoadCache->FetchCardsPrepare->FetchCards->FetchCardsProcess->Render*

```typescript
enum Mark {
  /** hippy 引擎创建时刻 */
  HippyCreate = 'HippyCreate',
  /** 构造器开始 */
  AppConstructorStart = 'AppConstructorStart',
  /** 卡片缓存加载开始 */
  LoadCacheStart = 'LoadCacheStart',
  /** 卡片缓存加载结束 */
  LoadCacheEnd = 'LoadCacheEnd',
  /** 首屏请求开始（卡片） */
  FetchCardsStart = 'FetchCardsStart',
  /** 首屏请求结束（卡片） */
  FetchCardsEnd = 'FetchCardsEnd',
  /** 首屏请求开始（tab） */
  FetchTabsStart = 'FetchTabsStart',
  /** 首屏请求结束（tab） */
  FetchTabsEnd = 'FetchTabsEnd',
  /** 渲染开始 */
  RenderStart = 'RenderStart',
  /** 首屏第一张卡片渲染结束 */
  RenderFirstCardEnd = 'RenderFirstCardEnd',
  /** 首屏最后一张卡片渲染结束 */
  RenderEnd = 'RenderEnd',
}
```

分析收集到的性能数据，发现耗时的大头主要在以下阶段

- 终端初始化耗时（虽然不是我们能直接控制的部分，但能够通过减包来间接优化）
- 缓存加载耗时（）
- 请求前准备耗时（将无依赖的异步操作并发）
- 渲染耗时（优化层级结构，组件重构）

减包工作是，除了冗余代码的清理，还包括项目的懒加载改造。

